*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="assemble.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS copyfile AS processbaseclass OF "assemble.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: oktocopyfile		&& Determines if it's OK to copy the file
	*</DefinedPropArrayMethod>

	Name = "copyfile"
	
	PROCEDURE oktocopyfile		&& Determines if it's OK to copy the file
		lparameters tcFile
		
	ENDPROC

	PROCEDURE processfile
		lparameters tcInputFile, ;
			tcOutputFile
		if This.OKToCopyFile(tcOutputFile)
			copy file (tcInputFile) to (tcOutputFile)
		endif This.OKToCopyFile(tcOutputFile)
		return not This.lErrorOccurred
		
	ENDPROC

ENDDEFINE

DEFINE CLASS copyoriginalfile AS copyfile OF "assemble.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	Name = "copyoriginalfile"
	
	PROCEDURE oktocopyfile		&& Determines if it's OK to copy the file
		* Only allow the file to be copied if we don't have an existing file with the
		* same stem.
		
		lparameters tcFile
		local lcFile, ;
			laFiles[1], ;
			lnFiles
		lcFile  = forceext(tcFile, '*')
		lnFiles = adir(laFiles, lcFile)
		return lnFiles = 0
		
	ENDPROC

ENDDEFINE

DEFINE CLASS fileiterator AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "assemble.h"
	*<DefinedPropArrayMethod>
		*m: getfiles		&& Fills aFiles with the files to process
		*m: process		&& Processes the files
		*p: cdirectory		&& The directory the files are in
		*p: cfileskeleton		&& The skeleton of the files to process
		*p: clogfile		&& The file to log errors to
		*p: cwritedir		&& The directory to write files to (if empty, the same directory as cDirectory is used)
		*p: nfiles		&& The number of files to process
		*p: oprocess		&& An object to process an individual file
		*a: aexclude[1,0]		&& An array of file extensions to exclude
		*a: afiles[1,0]		&& An array of the files to process
	*</DefinedPropArrayMethod>

	cdirectory = 		&& The directory the files are in
	cfileskeleton = *.*		&& The skeleton of the files to process
	clogfile = 		&& The file to log errors to
	cwritedir = 		&& The directory to write files to (if empty, the same directory as cDirectory is used)
	Name = "fileiterator"
	nfiles = 0		&& The number of files to process
	oprocess = .NULL.		&& An object to process an individual file
	Width = 17
	
	PROCEDURE getfiles		&& Fills aFiles with the files to process
		* Get a list of matching files, then remove undesired files.
		
		local laFiles[1], ;
			lnFiles, ;
			lnI, ;
			lnJ
		with This
			lnFiles = adir(laFiles, .cDirectory + .cFileSkeleton)
			if not empty(.aExclude[1])
				for lnI = 1 to lnFiles
					for lnJ = 1 to alen(.aExclude)
						if upper(justext(laFiles[lnI, 1])) == upper(.aExclude[lnJ])
							adel(laFiles, lnI)
							dimension laFiles[alen(laFiles, 1), alen(laFiles, 2)]
						endif upper(justext(laFiles[lnI, 1])) == upper(.aExclude[lnJ])
					next lnJ
				next lnI
			endif not empty(.aExclude[1])
			asort(laFiles)
			.nFiles = alen(laFiles, 1)
			dimension .aFiles[.nFiles, alen(laFiles, 2)]
			acopy(laFiles, .aFiles)
		endwith
		
	ENDPROC

	PROCEDURE Init
		This.aExclude[1] = ''
		
	ENDPROC

	PROCEDURE process		&& Processes the files
		* Process each file in our list, logging errors to the log file, and returning
		* .F. (but not terminating early) if any process failed.
		
		lparameters tcTitle
		local loTherm, ;
			llReturn, ;
			lnI, ;
			lcFile, ;
			lcMessage
		private plCancel
		with This
			assert vartype(.oProcess) = 'O' ;
				message 'Iterator.Process: oProcess must contain an object'
		
		* Use the same directory for writing files to if it isn't specified.
		
			.cWriteDir = iif(empty(.cWriteDir), .cDirectory, .cWriteDir)
		
		* Create a thermometer object.
		
			.nFiles = alen(.aFiles, 1)
			loTherm = newobject('SFProgressForm', 'SFTherm.vcx')
			loTherm.SetMaximum(.nFiles)
			loTherm.SetTitle(tcTitle)
			loTherm.cCancelProperty = 'plCancel'
		
		* Process each file.
		
			llReturn = .T.
			plCancel = .F.
			for lnI = 1 to .nFiles
				lcFile = .aFiles[lnI, 1]
				do case
					case not .oProcess.Process(.cDirectory + lcFile, ;
						.cWriteDir + lcFile)
						lcMessage = lcFile + ': ' + .oProcess.cErrorMessage + ccCRLF
						strtofile(lcMessage, .cLogFile, .T.)
						llReturn = .F.
					case plCancel
						llReturn = .F.
						exit
					otherwise
						loTherm.Update(lnI, 'Processing ' + lcFile + '...')
				endcase
			next lnI
			loTherm.Update(.nFiles, 'Processing ' + lcFile + '...')
		endwith
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS findbadtext AS replacetext OF "assemble.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "assemble.h"
	*<DefinedPropArrayMethod>
		*p: lcasesensitive		&& .T. to make the search case-sensitive
	*</DefinedPropArrayMethod>

	lcasesensitive = .F.		&& .T. to make the search case-sensitive
	Name = "findbadtext"
	
	PROCEDURE addsearchandreplace
		lparameters tcTopics, ;
			tcSearch, ;
			tcReplace, ;
			tlRequired, ;
			tlDebug
		dodefault(tcSearch, tcReplace, tlRequired, tlDebug)
		This.aReplace[This.nItems, 5] = tcTopics
		
	ENDPROC

	PROCEDURE Init
		dimension This.aReplace[1, 5]
		
	ENDPROC

	PROCEDURE processfile
		lparameters tcInputFile, ;
			tcOutputFile
		local lcString, ;
			llReturn, ;
			lnI, ;
			lcSearch, ;
			lnWildCardPos, ;
			lcBegin, ;
			lcEnd, ;
			llFound
		with This
		
		* Open the file and log if we find any of the "bad" text.
		
			lcString = filetostr(tcInputFile)
			llReturn = .T.
			for lnI = 1 to .nItems
				if not lower(juststem(tcInputFile)) $ .aReplace[lnI, 5]
					lcSearch = .aReplace[lnI, 1]
					if .lCaseSensitive
						llFound = at(lcSearch, lcString) > 0
					else
		* Note: use AT() if ATC() fails because of a bug: if search string too large,
		* ATC() returns 0 but AT() works OK
						llFound = atc(lcSearch, lcString) > 0
						if not llFound
							llFound = at(upper(lcSearch), upper(lcString)) > 0
						endif not llFound
					endif .lCaseSensitive
		
		* The search text was found, so set the error message.
		
					if llFound
						.cErrorMessage = .cErrorMessage + iif(empty(.cErrorMessage), ;
							'', ccCRLF) + lcSearch + ' found'
						llReturn = .F.
					endif llFound
				endif not lower(juststem(tcInputFile)) $ .aReplace[lnI, 5]
			next lnI
		endwith
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS fixbullets AS processbaseclass OF "assemble.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "assemble.h"
	Name = "fixbullets"
	
	PROCEDURE processfile
		lparameters tcInputFile, ;
			tcOutputFile
		local lcString, ;
			laLines[1], ;
			lnLines, ;
			llInList, ;
			lnLevel, ;
			lnOldIndent, ;
			lnI, ;
			lcLine, ;
			lnLine, ;
			lnIndent, ;
			lnPos, ;
			lcUL
		with This
		 
		* Read the contents to a file into a string. Bug out if there aren't any items
		* we're interested in.
		
			lcString = filetostr(tcInputFile)
			if atc(chr(183), lcString) = 0
				return .T.
			endif atc(chr(183), lcString) = 0
		
		* Create an array of lines and process each one.
		
			lnLines     = alines(laLines, lcString)
			llInList    = .F.
			lnLevel     = 0
			lnOldIndent = 0
			for lnI = 1 to lnLines
				lcLine = laLines[lnI]
				do case
		
		* Ignore this line if it's blank or we're supposed to omit it.
		
					case empty(lcLine) or lcLine = '***OMIT'
		
		* If we have a bullet, convert it to an item in a list. If this is the first
		* one, start the list.
		
					case at(chr(183), lcLine) > 0
						lnLine = 1
						do while not '</p>' $ lcLine
							lcLine = lcLine + ' ' + laLines[lnI + lnLine]
							laLines[lnI + lnLine] = '***OMIT'
							lnLine = lnLine + 1
						enddo while not '</p>' $ lcLine
						lnPos    = at('>', lcLine)
						lcLine   = substr(lcLine, lnPos + 1)
						lcLine   = alltrim(strtran(lcLine, chr(183)))
						lnIndent = 0
						do while lcLine = '&nbsp;'
							lcLine   = substr(lcLine, 7)
							lnIndent = lnIndent + 1
						enddo while lcLine = '&nbsp;'
						do case
							case lnIndent > lnOldIndent
								lnLevel = lnLevel + 1
								lcUL    = '<ul>'
							case lnIndent < lnOldIndent
								lnLevel = lnLevel - 1
								lcUL    = '</ul>'
							case llInList
								lcUL = ''
							otherwise
								lcUL = '<ul>'
						endcase
						laLines[lnI] = lcUL + '<li>' + lcLine
						llInList     = .T.
						lnOldIndent  = lnIndent
		
		* If we don't have a bullet but we were in a list, we're at the end of the
		* list.
		
					case llInList
						llInList = .F.
						lnLine   = lnI - 1
						do while laLines[lnLine] = '***OMIT'
							lnLine = lnLine - 1
						enddo while laLines[lnLine] = '***OMIT'
						laLines[lnLine] = laLines[lnLine] + replicate('</ul>', lnLevel)
				endcase
			next lnI
		
		* Now put the lines back into the string, skipping lines we previously marked
		* to omit.
		
			lcString = ''
			for lnI = 1 to lnLines
				if laLines[lnI] <> '***OMIT'
					lcString = lcString + laLines[lnI] + ccCRLF
				endif laLines[lnI] <> '***OMIT' ...
			next lnI
			strtofile(lcString, tcOutputFile)
		endwith
		return empty(This.cErrorMessage)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS fixhyperlinks AS processbaseclass OF "assemble.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "assemble.h"
	Name = "fixhyperlinks"
	
	PROCEDURE process
		lparameters tcInputFile, ;
			tcOutputFile
		local lcString, ;
			laLines[1], ;
			lnLines, ;
			lnI, ;
			lcLine, ;
			lnPos, ;
			lnLine, ;
			lcCheck, ;
			lcLink
		with This
		
		* Read the contents to a file into a string. Bug out if there aren't any tags
		* we're interested in.
		
			lcString = filetostr(tcInputFile)
			if atc('http://', lcString) = 0
				return .T.
			endif atc('http://', lcString) = 0
		
		* Create an array of lines and process each one.
		
			lnLines = alines(laLines, lcString)
			for lnI = 1 to lnLines
				lcLine = laLines[lnI]
				lnPos  = atc('<a', lcLine)
				do case
		
		* Ignore this line if we're supposed to omit it.
		
					case lcLine = '***OMIT'
		
		* If we have an <a> tag, combine subsequent lines as necessary and add the
		* TARGET keyword.
		
					case lnPos > 0
						lnLine  = 1
						lcCheck = substr(lcLine, lnPos)
						do while not '>' $ lcCheck
							lcCheck = laLines[lnI + lnLine]
							lcLine  = lcLine + iif(right(lcLine, 1) = ' ' or ;
								left(lcCheck, 1) = ' ', '', ' ') + lcCheck
							laLines[lnI + lnLine] = '***OMIT'
							lnLine = lnLine + 1
						enddo while not '>' $ lcCheck
						lcLink = strextract(lcLine, '<a href="http://', '>')
						if not empty(lcLink)
							laLines[lnI] = strtran(lcLine, '<a href="http://' + ;
								lcLink + '>', '<a href="http://' + lcLink + ;
								' target="_blank">')
						endif not empty(lcLink)
				endcase
			next lnI
		
		* Now put the lines back into the file and write it out, skipping lines we
		* previously marked to omit.
		
			lcString = ''
			for lnI = 1 to lnLines
				if laLines[lnI] <> '***OMIT'
					lcString = lcString + laLines[lnI] + ccCRLF
				endif laLines[lnI] <> '***OMIT' ...
			next lnI
			strtofile(lcString, tcOutputFile)
		endwith
		return empty(This.cErrorMessage)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS fiximages AS processbaseclass OF "assemble.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "assemble.h"
	Name = "fiximages"
	
	PROCEDURE processfile
		lparameters tcInputFile, ;
			tcOutputFile
		local lcString, ;
			laLines[1], ;
			lnLines, ;
			lnI, ;
			lcLine, ;
			lnLine, ;
			lcCheck, ;
			lcID, ;
			lcWidth, ;
			lcHeight, ;
			lcSrc
		with This
		
		* Read the contents to a file into a string. Bug out if there aren't any tags
		* we're interested in.
		
			lcString = filetostr(tcInputFile)
			if atc('<img', lcString) = 0
				return .T.
			endif atc('<img', lcString) = 0
		
		* Create an array of lines and process each one.
		
			lnLines = alines(laLines, lcString)
			for lnI = 1 to lnLines
				lcLine = laLines[lnI]
				do case
		
		* Ignore this line if we're supposed to omit it.
		
					case lcLine = '***OMIT'
		
		* If we have an <img> tag, combine subsequent lines as necessary, remove the ID
		* attribute, strip out any style information, and fix the SRC reference.
		
					case atc('<img', lcLine) > 0
						lnLine  = 1
						lcCheck = substr(lcLine, atc('<img', lcLine))
						do while not '>' $ lcCheck
							lcCheck = laLines[lnI + lnLine]
							lcLine  = lcLine + iif(right(lcLine, 1) = ' ' or ;
								left(lcCheck, 1) = ' ', '', ' ') + lcCheck
							laLines[lnI + lnLine] = '***OMIT'
							lnLine = lnLine + 1
						enddo while not '>' $ lcCheck
						lcLine = alltrim(lcLine)
						if lcLine = '<p class='
							lcLine = substr(lcLine, at('<', lcLine, 2))
						endif lcLine = '<p class='
						lcID     = strextract(lcLine, ' id="', '"', 1, 1)
						lcLine   = strtran(lcLine, ' id="' + lcID + '"')
						lcLine   = strtran(lcLine, '  src=', ' src=')
						lcSrc    = strextract(lcLine, ' src="', '"', 1, 1)
						lcFile   = justfname(lcSrc)
						if inlist(upper(juststem(lcFile)), 'S2C4A', 'S2C4B', 'S2C5C', ;
							'S2C5E', 'S2C5G', 'S4G357A', 'S4G364A', 'S4G373A', ;
							'S5C1A', 'S5C1B', 'S5C3A', 'S5C4A', 'S5C4B', 'S5C4C', ;
							'S5C4D', 'S5C4E')
							lcWidth  = strextract(lcLine, ' width=', ' ', 1, 1)
							lcLine   = strtran(lcLine, ' width=' + lcWidth)
							lcHeight = strextract(lcLine, ' height=', ' ', 1, 1)
							lcLine   = strtran(lcLine, ' height=' + lcHeight)
						endif inlist(upper(juststem(lcFile)) ...
						if '..\' $ lcSrc
							laLines[lnI] = strtran(lcLine, lcSrc, lcFile)
						else
							laLines[lnI] = lcLine
						endif '..\' $ lcSrc
						if not file(fullpath(lcFile, tcInputFile))
							.cErrorMessage = lcFile + ' not found'
						endif not file(fullpath(lcFile, tcInputFile))
				endcase
			next lnI
		
		* Now put the lines back into the file and write it out, skipping lines we
		* previously marked to omit.
		
			lcString = ''
			for lnI = 1 to lnLines
				if laLines[lnI] <> '***OMIT'
					lcString = lcString + laLines[lnI] + ccCRLF
				endif laLines[lnI] <> '***OMIT' ...
			next lnI
			strtofile(lcString, tcOutputFile)
		endwith
		return empty(This.cErrorMessage)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS fixpreformatted AS processbaseclass OF "assemble.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "assemble.h"
	*<DefinedPropArrayMethod>
		*m: getpreline		&& Process a preformatted line
		*a: alines[1,0]		&& An array of lines that make up the file
	*</DefinedPropArrayMethod>

	Name = "fixpreformatted"
	
	PROCEDURE getpreline		&& Process a preformatted line
		* Process a preformatted line: strip off the <P CLASS> tag at the start of the
		* line, then find the matching </P> tag (which may not be on the same line, so
		* we'll combine lines until we find it and mark those lines as omitted from
		* further processing and output), and return the line without the </P>.
		
		lparameters tcLine, ;
			tnLine
		local lnPos, ;
			lnStart, ;
			lcLine, ;
			lnLine
		with This
			lnPos   = atc('<p class=Preformatted>', tcLine)
			lnStart = lnPos + 22
			if lnPos = 0
				lnPos   = atc('<p class=Preformatted ', tcLine)
				lnStart = at('>', tcline) + 1
			endif lnPos = 0
			lcLine = substr(tcLine, lnStart)
			lnLine = tnLine + 1
			do while right(lcLine, 4) <> '</p>'
				lcLine          = lcLine + ' ' + alltrim(.aLines[lnLine])
				.aLines[lnLine] = '***OMIT'
				lnLine          = lnLine + 1
			enddo while right(lcLine, 4) <> '</p>'
			lcLine = left(lcLine, len(lcLine) - 4)
		
		* Flag if we have a <BR> in the code, which messes things up.
		
			if atc('<br>', lcLine) > 0
				.cErrorMessage = 'Soft return found in code'
			endif atc('<br>', lcLine) > 0
		endwith
		return lcLine
		
	ENDPROC

	PROCEDURE processfile
		lparameters tcInputFile, ;
			tcOutputFile
		local lcString, ;
			lnLines, ;
			llInPre, ;
			lnI, ;
			lcLine, ;
			lnLine
		with This
		
		* Read the contents to a file into a string. Bug out if there aren't any tags
		* we're interested in.
		
			lcString = filetostr(tcInputFile)
			if atc('<p class=Preformatted', lcString) = 0
				return .T.
			endif atc('<p class=Preformatted', lcString) = 0
		
		* Create an array of lines and process each one.
		
			lnLines  = alines(.aLines, lcString)
			llInPre  = .F.
			for lnI = 1 to lnLines
				lcLine = .aLines[lnI]
				do case
		
		* If we're processing preformatted lines and come across a blank line, we'll
		* omit it since Word seems to insert these where they don't belong.
		
					case llInPre and empty(lcLine)
						.aLines[lnI] = '***OMIT'
		
		* Ignore this line if we're supposed to omit it or we're not on a preformatted
		* line and we weren't processing them.
		
					case lcLine = '***OMIT' or ;
						(alltrim(lcLine) <> '<p class=Preformatted' and not llInPre)
		
		* We're not on a preformatted line and we were processing them, so flag that
		* we're not processing them anymore and add </PRE> to the end of the first
		* prior line that isn't blank or omitted.
		
					case alltrim(lcLine) <> '<p class=Preformatted'
						llInPre = .F.
						for lnLine = lnI - 1 to 1 step -1
							do case
								case empty(.aLines[lnLine]) or ;
									.aLines[lnLine] = '&nbsp;'
									 .aLines[lnLine] = '***OMIT'
								case .aLines[lnLine] <> '***OMIT'
									.aLines[lnLine] = .aLines[lnLine] + '</pre>'
									exit
							endcase
						next lnLine
		
		* We're on a preformatted line and we're processing them, so process the line.
		
					case llInPre
						.aLines[lnI] = .GetPreLine(lcLine, lnI)
		
		* We're on a preformatted line and we weren't processing them, so process the
		* line, starting it with <PRE>, and flag that we're now processing them.
		
					otherwise
						.aLines[lnI] = '<pre>' + .GetPreLine(lcLine, lnI)
						llInPre = .T.
				endcase
			next lnI
		
		* Now put the lines back into the file and write it out, skipping lines we
		* previously marked to omit and those that are empty tags.
		
			lcString = ''
			for lnI = 1 to lnLines
				if .aLines[lnI] <> '***OMIT' and .aLines[lnI] <> '<pre></pre>'
					lcString = lcString + .aLines[lnI] + ccCRLF
				endif .aLines[lnI] <> '***OMIT' ...
			next lnI
			strtofile(lcString, tcOutputFile)
		endwith
		return empty(This.cErrorMessage)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS fixtables AS processbaseclass OF "assemble.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "assemble.h"
	Name = "fixtables"
	
	PROCEDURE processfile
		lparameters tcInputFile, ;
			tcOutputFile
		local lcString, ;
			lnLines, ;
			laLines[1], ;
			lnI, ;
			lcLine, ;
			lnTableLine, ;
			llInTable, ;
			llPre, ;
			lnLine, ;
			lcStyle, ;
			lcWidth, ;
			lnRowLine, ;
			lnCells, ;
			lnWidth, ;
			lnJ, ;
			lnCell
		with This
		
		* Read the contents to a file into a string. Bug out if there aren't any tags
		* we're interested in.
		
			lcString = filetostr(tcInputFile)
			if atc('<table', lcString) = 0
				return .T.
			endif atc('<table', lcString) = 0
		
		* Create an array of lines and process each one.
		
			lnLines  = alines(laLines, lcString)
			for lnI = 1 to lnLines
				lcLine = laLines[lnI]
				do case
		
		* Ignore this line if we're supposed to omit it.
		
					case lcLine = '***OMIT'
		
		* If we have a <table> tag, save the line number, strip out any STYLE
		* attribute (we may have to combine subsequent lines until we find the > and
		* mark those lines as omitted), and fix the width.
		
					case atc('<table ', lcLine) > 0
						lnTableLine = lnI
						llInTable   = .T.
						llPre       = .F.
						lnLine      = 1
						do while not '>' $ lcLine
							lcLine = lcLine + laLines[lnI + lnLine]
							laLines[lnI + lnLine] = '***OMIT'
							lnLine = lnLine + 1
						enddo while not '>' $ lcLine
						lcStyle      = strextract(lcLine, " style='", "'", 1, 1)
						lcLine       = strtran(lcLine, " style='" + lcStyle + "'")
						lcWidth      = strextract(lcLine, 'width=', ' ', 1, 1)
						if empty(lcWidth)
							lcWidth = strextract(lcLine, 'width=', '>', 1, 1)
						endif empty(lcWidth)
						if empty(lcWidth)
							laLines[lnI] = strtran(lcLine, '<table ', ;
								'<table width=100% ', 1, 1, 1)
						else
							laLines[lnI] = strtran(lcLine, lcWidth, '100%')
						endif empty(lcWidth)
		
		* If we have a </table> tag and we didn't have any code, add a <BR> after it.
		
					case atc('</table>', lcLine) > 0
						llInTable = .F.
						if not llPre
							laLines[lnI] = lcLine + ccCRLF + '<br>'
						endif not llPre
		
		* If we're at the start of a row, keep track of the line number and initialize
		* a cell counter. Also, we'll replace the line with just "<tr>" in case there
		* was any STYLE attribute.
		
					case atc('<tr', lcLine) > 0
						lnRowLine = lnI
						lnCells   = 0
						laLines[lnI] = '<tr>'
		
		* If we're at the end of a row, fix up the cell widths for the row.
		
					case atc('</tr>', lcLine) > 0
						lnWidth = 0
						for lnJ = 1 to lnCells
							lnWidth = lnWidth + laCells[lnJ]
						next lnJ
						lnCell = 0
						for lnJ = lnRowLine + 1 to lnI - 1
							if atc('<td ', laLines[lnJ]) > 0
								lnCell  = lnCell + 1
								lcWidth = strextract(laLines[lnJ], 'width=', ' ', 1, 1)
								if empty(lcWidth)
									lcWidth = strextract(laLines[lnJ], 'width=', '>', ;
										1, 1)
								endif empty(lcWidth)
								if not empty(lcWidth)
									laLines[lnJ] = strtran(laLines[lnJ], lcWidth, ;
										transform(int(laCells[lnCell]/lnWidth * 100 + 0.5), ;
										'99%'))
								endif not empty(lcWidth)
							endif atc('<td ', laLines[lnJ]) > 0
						next lnJ
		
		* If we have a <td> tag, combine lines as necessary until we have the ending
		* tag, adjust the <table> line if we have a BORDER attribute, strip out any
		* STYLE attribute, and save the width in an array.
		
					case atc('<td ', lcLine) > 0
						lnLine = 1
						do while not '>' $ lcLine
							lcLine = lcLine + laLines[lnI + lnLine]
							laLines[lnI + lnLine] = '***OMIT'
							lnLine = lnLine + 1
						enddo while not '>' $ lcLine
						lcStyle = strextract(lcLine, " style='", "'", 1, 1)
						do case
							case atc('border', lcStyle) = 0
							case atc('border=0', laLines[lnTableLine]) > 0
								laLines[lnTableLine] = strtran(laLines[lnTableLine], ;
									'border=0', 'border', -1, -1, 1)
							case atc('border', laLines[lnTableLine]) = 0
								laLines[lnTableLine] = strtran(laLines[lnTableLine], ;
									'<table ', '<table border ', -1, -1, 1)
						endcase
						laLines[lnI] = strtran(lcLine, " style='" + lcStyle + "'")
						lnWidth      = val(strextract(lcLine, 'width=', ' ', 1, 1))
						lnCells      = lnCells + 1
						dimension laCells[lnCells]
						laCells[lnCells] = lnWidth
		
		* If we're in a table and have a code section, flag that.
		
					case llInTable and atc('<pre', lcLine) > 0
						llPre = .T.
				endcase
			next lnI
		
		* Now put the lines back into the file and write it out, skipping lines we
		* previously marked to omit.
		
			lcString = ''
			for lnI = 1 to lnLines
				if laLines[lnI] <> '***OMIT'
					lcString = lcString + laLines[lnI] + ccCRLF
				endif laLines[lnI] <> '***OMIT' ...
			next lnI
			strtofile(lcString, tcOutputFile)
		endwith
		return empty(This.cErrorMessage)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS fixtitles AS processbaseclass OF "assemble.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "assemble.h"
	Name = "fixtitles"
	
	PROCEDURE process
		lparameters tcInputFile, ;
			tcOutputFile
		local lcString, ;
			laLines[1], ;
			lnLines, ;
			lnI, ;
			lcLine, ;
			lnLine, ;
			lcCheck, ;
			lcID, ;
			lcSrc
		with This
		
		* Read the contents to a file into a string.
		
			lcString = filetostr(tcInputFile)
		
		* Create an array of lines and process each one.
		
			lnLines = alines(laLines, lcString)
			for lnI = 1 to lnLines
				lcLine = laLines[lnI]
				do case
		
		* Ignore this line if we're supposed to omit it.
		
					case lcLine = '***OMIT'
		
		* If we have an <p class=h2> tag, combine subsequent lines as necessary and
		* remove any <BR>.
		
					case atc('<p class=h2>', lcLine) > 0
						lnLine = 1
						do while not '</P>' $ upper(lcLine)
							lcCheck = laLines[lnI + lnLine]
							lcLine  = lcLine + iif(right(lcLine, 1) = ' ' or ;
								left(lcCheck, 1) = ' ', '', ' ') + lcCheck
							laLines[lnI + lnLine] = '***OMIT'
							lnLine = lnLine + 1
						enddo while not '</P>' $ upper(lcLine)
						lcLine = alltrim(lcLine)
						laLines[lnI] = strtran(lcLine, '<br>')
				endcase
			next lnI
		
		* Now put the lines back into the file and write it out, skipping lines we
		* previously marked to omit.
		
			lcString = ''
			for lnI = 1 to lnLines
				if laLines[lnI] <> '***OMIT'
					lcString = lcString + laLines[lnI] + ccCRLF
				endif laLines[lnI] <> '***OMIT' ...
			next lnI
			strtofile(lcString, tcOutputFile)
		endwith
		return empty(This.cErrorMessage)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS generatehtml AS processbaseclass OF "assemble.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "assemble.h"
	*<DefinedPropArrayMethod>
		*p: oword		&& A reference to a Word object
	*</DefinedPropArrayMethod>

	Name = "generatehtml"
	oword = .NULL.		&& A reference to a Word object
	
	PROCEDURE Destroy
		* Close Word before we exit.
		
		if vartype(This.oWord) = 'O'
			This.oWord.Quit()
		endif vartype(This.oWord) = 'O'
		
	ENDPROC

	PROCEDURE Init
		* Instantiate Word.
		
		This.oWord = createobject('Word.Application')
		
	ENDPROC

	PROCEDURE processfile
		lparameters tcInputFile, ;
			tcOutputFile
		local loDocument, ;
			llReturn
		with This
		
		* Just copy graphic files to the output directory.
		
			if inlist(upper(justext(tcInputFile)), 'JPG', 'GIF', 'BMP', 'TIF', 'HTM', ;
				'HTML', 'CSS')
				copy file (tcInputFile) to (tcOutputFile)
				llReturn = .T.
		
		* Open the file, save it as HTML, and close it.
		
			else
				loDocument = .oWord.Documents.Open(tcInputFile)
				llReturn   = not .lErrorOccurred
				if llReturn
					loDocument.Revisions.AcceptAll()
					.cFile = lower(forceext(tcOutputFile, 'html'))
					loDocument.SaveAs(.cFile, wdFormatHTML)
					loDocument.Close()
					llReturn = not .lErrorOccurred
				endif llReturn
			endif inlist(upper(justext(tcInputFile)) ...
		endwith
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS handleseealso AS processbaseclass OF "assemble.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "assemble.h"
	*<DefinedPropArrayMethod>
		*p: ctopicstable		&& The name and path for the topics table
	*</DefinedPropArrayMethod>

	ctopicstable = newallcandf		&& The name and path for the topics table
	Name = "handleseealso"
	
	PROCEDURE process
		lparameters tcInputFile, ;
			tcOutputFile
		if not used('TOPICS')
			use (This.cTopicsTable) alias TOPICS again shared
		endif not used('TOPICS')
		set order to TOPIC in TOPICS
		set filter to NGROUP <> 0 in TOPICS
		return dodefault(tcInputFile, tcOutputFile)
		
	ENDPROC

	PROCEDURE processfile
		lparameters tcInputFile, ;
			tcOutputFile
		local lcString, ;
			lcOriginal, ;
			lnPos1, ;
			lnPos2, ;
			lcOriginalSeeAlso, ;
			lcRemove, ;
			lnSelect, ;
			laSeeAlso[1], ;
			lnSeeAlso, ;
			lcSeeAlso, ;
			lnI, ;
			lcTopic, ;
			lcLinkFile, ;
			lcUpdated
		with This
		
		* Ensure the topics table can be found.
		
			assert not empty(.cTopicsTable) and file(forceext(.cTopicsTable, 'DBF')) ;
				message 'HandleSeeAlso.ProcessFile: topics table not found'
		
		* Open the file and look for "See Also".
		
			store filetostr(tcInputFile) to lcString, lcOriginal
			lnPos1 = atc('See Also', lcString)
		
		* If we found it, get everything up to the end of the table.
		
			if lnPos1 > 0
				lcString = substr(lcString, lnPos1)
				lnPos2   = atc('</table>', lcString)
				lcString = left(lcString, lnPos2 + 7)
		
		* Save the original "see also" topics list so we can later replace it.
		
				lcOriginalSeeAlso = lcString
		
		* Strip all HTML tags out.
		
				lcString = '<' + strextract(lcString, '<TD', '</TD', 1, 1)
				do while '<' $ lcString and not lcString == '<'
					lcRemove = strextract(lcString, '<', '>')
					lcString = strtran(lcString, '<' + lcRemove + '>')
				enddo while '<' $ lcString ...
		
		* Remove any remaining CRLF in the middle of the string.
		
				lcString = alltrim(strtran(strtran(lcString, ccCR), ccLF))
		
		* Select the topics table.
		
				lnSelect = select()
				select TOPICS
		
		* Create a list of "see also" topics and process each one. Strip extra spaces
		* in each topic.
		
				lnSeeAlso = alines(laSeeAlso, lcString, .T., ',')
				lcSeeAlso = left(lcOriginalSeeAlso, atc('<p>', lcOriginalSeeAlso) + 2)
				for lnI = 1 to lnSeeAlso
					lcTopic = strtran(alltrim(laSeeAlso[lnI]), '  ', ' ')
		
		* Find the topic in the topics table. If we found it, see if it's a potentially
		* ambiguous topic (if the next topic name in alphabetical order has the same
		* starting characters, with a few exceptions), log that.
		
					if lcTopic = '@ ... '
						lcTopic = '@...' + substr(lcTopic, 7)
					endif lcTopic = '@ ... '
					if seek(upper(lcTopic), 'TOPICS', 'TOPIC')
						if not inlist(upper(lcTopic), '@...SAY', 'APPEND', ;
							'APPEND FROM', 'BUILD', 'COMPILE', 'CONTROL', 'COPY', ;
							'COPY TO', 'CREATE', 'DATAENVIRONMENT', 'DELETE', 'DO', ;
							'FOR', 'HELP', 'HIDE', 'MENU', 'MOVE', 'PACK', 'READ', ;
							'RENAME', 'REPLACE', 'SHOW') and ;
							not upper(lcTopic) == 'SET'
							lnGroup = NGROUP
							skip
							if upper(TOPIC) = upper(lcTopic) + ' ' and NGROUP <> lnGroup
								.cErrorMessage = .cErrorMessage + ;
									iif(empty(.cErrorMessage), '', ccCRLF) + ;
									'Potentially ambiguous link: ' + lcTopic
							endif upper(TOPIC) = upper(lcTopic) + ' ' ...
							skip -1
						endif not inlist(upper(lcTopic), ...
		
		* Create an anchor tag.
		
						lcLinkFile = 's4g' + padl(NGROUP, 3, '0') + '.html'
						lcSeeAlso  = lcSeeAlso + iif(lnI = 1, '', ', ') + ;
							'<A HREF="' + lcLinkFile + '">' + lcTopic + '</A>'
		
		* The link file couldn't be found: we'll still add the link because we may just
		* be testing, but we'll also log an error.
		
						if not file(addbs(justpath(tcInputFile)) + lcLinkFile)
							.cErrorMessage = .cErrorMessage + ;
								iif(empty(.cErrorMessage), '', ccCRLF) + ;
								'SeeAlso link file ' + lcLinkFile + ' (' + lcTopic + ;
								') not found'
						endif file(addbs ...
		
		* The topic wasn't found in the topics table.
		
					else
						.cErrorMessage = .cErrorMessage + ;
							iif(empty(.cErrorMessage), '', ccCRLF) + ;
							'SeeAlso topic (' + lcTopic + ') not found'
					endif seek(upper(lcTopic), 'TOPICS', 'TOPIC')
				next lnI
		
		* Write the updated See Also to the file.
		
				if lcOriginalSeeAlso $ lcOriginal
					lcSeeAlso = lcSeeAlso + '</p>' + ccCRLF + '  </td>' + ccCRLF + ;
						' </tr>' + ccCRLF + '</table>'
					lcUpdated = strtran(lcOriginal, lcOriginalSeeAlso, lcSeeAlso)
					strtofile(lcUpdated, tcOutputFile)
				else
					.cErrorMessage = 'Could not process text in See Also'
				endif lcOriginalSeeAlso $ lcOriginal
		
		* Reselect the former workarea before we exit.
		
				select (lnSelect)
			endif lnPos1 > 0
		endwith
		return empty(This.cErrorMessage)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS hyperlinkkeywords AS processbaseclass OF "assemble.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: ctopicstable		&& The name and path for the topics table
	*</DefinedPropArrayMethod>

	ctopicstable = 		&& The name and path for the topics table
	Name = "hyperlinkkeywords"
	
	PROCEDURE process
		lparameters tcInputFile, ;
			tcOutputFile
		if not used('TOPICS')
			use (This.cTopicsTable) alias TOPICS again shared
		endif not used('TOPICS')
		set filter to NGROUP <> 0 in TOPICS
		return dodefault(tcInputFile, tcOutputFile)
		
	ENDPROC

	PROCEDURE processfile
		lparameters tcInputFile, ;
			tcOutputFile
		local lcString, ;
			lnTags, ;
			lnI, ;
			lcOriginal, ;
			lcText, ;
			laWords[1], ;
			lnWords, ;
			lcReplace, ;
			lnWord, ;
			lcWord, ;
			llChanged
		with This
		
		* Ensure the topics table can be found.
		
			assert not empty(.cTopicsTable) and file(forceext(.cTopicsTable, 'DBF')) ;
				message 'HyperlinkKeywords.ProcessFile: topics table not found'
		
		* Open the file and see how many <P> tags we have to process.
		
			lcString = filetostr(tcInputFile)
			lnTags   = occurs('<P>', upper(lcString))
		
		* Process each tag. If we find a keyword in it (we'll ignore certain keywords
		* like DATETIME and those that are upper-cased, which are likely Fox2x
		* keywords), replace it with a hyperlinked keyword. Look preferentially for
		* topics with "PROPERTY", "METHOD", or "EVENT" in the topic name to avoid
		* selecting a command (such as ERROR) with a similar name.
		
			for lnI = 1 to lnTags
				lcOriginal = strextract(lcString, '<P>', '</P>', lnI, 1)
				lcText     = chrtran(lcOriginal, chr(13) + chr(10), '')
				lnWords    = alines(laWords, lcText, .T., ',')
				lcReplace  = ''
				for lnWord = 1 to lnWords
					lcWord = alltrim(laWords[lnWord])
					lcSeek = upper(lcWord)
					do case
						case getwordcount(lcWord) > 1
							lcReplace = ''
							exit
						case empty(lcWord) or (lcWord = lcSeek and not '(' $ lcWord) or ;
							lcSeek == 'DATETIME' or lcSeek == 'OBJECT'
						case seek(lcSeek + ' PROPERTY', 'TOPICS', 'TOPIC') or ;
							seek(lcSeek + ' METHOD', 'TOPICS', 'TOPIC') or ;
							seek(lcSeek + ' EVENT', 'TOPICS', 'TOPIC') or ;
							seek(lcSeek, 'TOPICS', 'TOPIC')
							lcReplace = lcReplace + iif(empty(lcReplace), '', ', ') + ;
								'<a href="s4g' + padl(TOPICS.NGROUP, 3, '0') + ;
								'.html">' + lcWord + '</a>'
					endcase
				next lnWord
				if not empty(lcReplace)
					lcString  = strtran(lcString, '<P>' + lcOriginal + '</P>', ;
						'<p>' + lcReplace + '</p>', -1, -1, 1)
					llChanged = .T.
				endif not empty(lcReplace)
			next lnI
		
		* If everything went OK, write out the changes to the file.
		
			if llChanged
				strtofile(lcString, tcOutputFile)
			else
				.cErrorMessage = 'Did not find any text to hyperlink'
			endif llChanged
		endwith
		return llChanged
		
	ENDPROC

ENDDEFINE

DEFINE CLASS processbaseclass AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "assemble.h"
	*<DefinedPropArrayMethod>
		*m: process		&& Processes the specified file
		*m: processfile		&& Process the file
		*p: cerrormessage		&& The message about a problem that occurred during processing
		*p: cfile		&& The file currently being processed
		*p: lerroroccurred		&& .T. if an error occurred
	*</DefinedPropArrayMethod>

	cerrormessage = 		&& The message about a problem that occurred during processing
	cfile = 		&& The file currently being processed
	lerroroccurred = .F.		&& .T. if an error occurred
	Name = "processbaseclass"
	Width = 17
	
	PROCEDURE Error
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local laError[1]
		aerror(laError)
		This.cErrorMessage  = laError[2]
		This.lErrorOccurred = .T.
		
	ENDPROC

	PROCEDURE process		&& Processes the specified file
		lparameters tcInputFile, ;
			tcOutputFile
		local lcFile, ;
			llReturn
		with This
		
		* Blank the error message so we don't use one from a previous file.
		
			.cErrorMessage = ''
		
		* Ensure the file exists.
		
			.cFile   = tcInputFile
			lcFile   = justfname(tcInputFile)
			llReturn = file(tcInputFile)
		
		* Open the file and then process it.
		
			if llReturn
				llReturn = .ProcessFile(tcInputFile, tcOutputFile)
		
		* The file wasn't found, so set the error message.
		
			else
				.cErrorMessage = 'File not found'
			endif llReturn
		
		* Include any error occurrence in the return value.
		
			llReturn = llReturn and not .lErrorOccurred
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE processfile		&& Process the file
		lparameters tcInputFile, ;
			tcOutputFile
		
	ENDPROC

ENDDEFINE

DEFINE CLASS replacetext AS processbaseclass OF "assemble.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: addsearchandreplace		&& Adds a search and replace pair to the list of items to check
		*p: nitems		&& The number of search and replace items
		*a: areplace[1,0]		&& An array of search and replace items
	*</DefinedPropArrayMethod>

	PROTECTED areplace,nitems
	Name = "replacetext"
	nitems = 0		&& The number of search and replace items
	
	PROCEDURE addsearchandreplace		&& Adds a search and replace pair to the list of items to check
		lparameters tcSearch, ;
			tcReplace, ;
			tlRequired, ;
			tlDebug
		
		* Ensure the parameters were passed.
		
		assert vartype(tcSearch) = 'C' ;
			message 'ReplaceText.AddSearchAndReplace: search text not specified'
		assert vartype(tcReplace) = 'C' ;
			message 'ReplaceText.AddSearchAndReplace: replace text not specified'
		assert vartype(tlRequired) = 'L' ;
			message 'ReplaceText.AddSearchAndReplace: required parameter not specified'
		
		* Add them to a new row in the array.
		
		with This
			.nItems = iif(empty(.aReplace[1]), 1, alen(.aReplace, 1) + 1)
			dimension .aReplace[.nItems, alen(.aReplace, 2)]
			.aReplace[.nItems, 1] = tcSearch
			.aReplace[.nItems, 2] = tcReplace
			.aReplace[.nItems, 3] = tlRequired
			.aReplace[.nItems, 4] = tlDebug
		endwith
		
	ENDPROC

	PROCEDURE Init
		dimension This.aReplace[1, 4]
		
	ENDPROC

	PROCEDURE processfile
		lparameters tcInputFile, ;
			tcOutputFile
		local lcString, ;
			llReturn, ;
			lnI, ;
			lcSearch, ;
			lcReplace, ;
			lnWildCardPos, ;
			lcBegin, ;
			lcEnd, ;
			lnLastPos, ;
			lnPos, ;
			llFound
		with This
		
		* Open the file and process each set of search and replace items. We'll use
		* TEXTMERGE() on the replacement text because it may have some processing stuff
		* (such as the filename).
		
			lcString = filetostr(tcInputFile)
			llReturn = .T.
			for lnI = 1 to .nItems
				lcSearch  = .aReplace[lnI, 1]
				lcReplace = textmerge(.aReplace[lnI, 2])
				lnWildCardPos = at('*', lcSearch)
				if lnWildCardPos > 0
					lcBegin = left(lcSearch,   lnWildCardPos - 1)
					lcEnd   = substr(lcSearch, lnWildCardPos + 1)
				endif lnWildCardPos > 0
		
		* Turn on debugging if we're supposed to.
		
				if .aReplace[lnI, 4]
					set step on
				endif .aReplace[lnI, 4]
				lnLastPos = 0
		* Check LEN = 0 rather than EMPTY(), since CRLF is a valid string but EMPTY()
				do while len(lcSearch) > 0
		
		* If we have a wild card character, we'll find the actual text first.
		
					if lnWildCardPos > 0
						lcSearch = strextract(lcString, lcBegin, lcEnd, 1, 1)
		*!*	* Check LEN = 0 rather than EMPTY(), since CRLF is a valid string but EMPTY()
		*!*					if len(lcSearch) = 0
		*!*						llFound = .F.
		*!*					else
		*!*						lcSearch = lcBegin + lcSearch + lcEnd
		*!*	* Note: use AT() if ATC() fails because of a bug: if search string too large,
		*!*	* ATC() returns 0 but AT() works OK
		*!*						lnPos   = atc(lcSearch, lcString)
		*!*	*** causes a problem if two search strings back to back: only first one removed
		*!*	***					llFound = lnPos > 0 and lnPos <> lnLastPos
		*!*						llFound = lnPos > 0
		*!*						if lnPos = 0
		*!*							lnPos   = at(upper(lcSearch), upper(lcString))
		*!*	***						llFound = lnPos > 0 and lnPos <> lnLastPos
		*!*							llFound = lnPos > 0
		*!*						endif lnPos = 0
		*!*					endif len(lcSearch) = 0
		*!*				else
		*!*					llFound = atc(lcSearch, lcString) > 0
		*** NEW CODE
		* Check LEN = 0 rather than EMPTY(), since CRLF is a valid string but EMPTY()
						if len(lcSearch) > 0
							lcSearch = lcBegin + lcSearch + lcEnd
						endif len(lcSearch) > 0
					endif lnWildCardPos > 0
		
		* Now that we know what to search for, try to find it using a case-insensitive
		* search. Note the use of AT() if ATC() fails because of a bug: if the search
		* string is too large, ATC() returns 0 but AT() works OK.
		
		* Check LEN = 0 rather than EMPTY(), since CRLF is a valid string but EMPTY()
					if len(lcSearch) > 0
						lnPos   = atc(lcSearch, lcString)
						llFound = lnPos > 0
						if lnPos = 0
							lnPos   = at(upper(lcSearch), upper(lcString))
							llFound = lnPos > 0
						endif lnPos = 0
					else
						llFound = .F.
					endif len(lcSearch) > 0
		*** END OF NEW CODE
					do case
		
		* We found the search text, so replace it with the replacement text if they're
		* not the same.
		
						case llFound and not lcSearch == lcReplace
							lcString = strtran(lcString, lcSearch, lcReplace, -1, -1, ;
								1)
							if lnWildCardPos = 0
								lcSearch = ''
							endif lnWildCardPos = 0
		
		* The search text wasn't found and it's required, so set the error message.
		
						case not llFound and .aReplace[lnI, 3] and lnLastPos = 0
							.cErrorMessage = lcSearch + ' not found'
							llReturn       = .F.
							lcSearch       = ''
		
		* The search text wasn't found, so we're done looking for this item.
		
						otherwise
							lcSearch = ''
					endcase
					lnLastPos = iif(lnWildCardPos > 0, lnPos, 0)
				enddo while len(lcSearch) > 0
			next lnI
		
		* If everything went OK, write out the changes to the file.
		
			if llReturn
				strtofile(lcString, tcOutputFile)
			endif llReturn
		endwith
		return llReturn
		
	ENDPROC

ENDDEFINE
