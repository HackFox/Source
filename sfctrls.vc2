*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="sfctrls.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS sfcheckbox AS checkbox 		&& Base class for CheckBox objects
 	*< CLASSDATA: Baseclass="checkbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: anychange		&& Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place.
		*m: release		&& Releases the object.
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*m: updatecontrolsource		&& Updates the ControlSource with the new value
		*m: validation		&& Abstract method for custom validation code
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class.
		*p: builderx		&& Holds the name of the preferred custom builder
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to an SFShortcutMenu object
	*</DefinedPropArrayMethod>

	AutoSize = .T.
	BackStyle = 0
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class.
	builderx = ( home() + 'wizards\builderd, builderdform')		&& Holds the name of the preferred custom builder
	Caption = "Check1"
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Name = "sfcheckbox"
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to an SFShortcutMenu object
	Value = .F.
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:					SFCheckBox
		* Based On:					CheckBox
		* Purpose:					Base class for all CheckBox objects
		* Author:					Doug Hennig
		* Copyright:				(c) 1996, 2000 Stonefield Systems Group Inc.
		* Last revision:			01/24/2001
		* Include file:				SFCTRLS.H
		*
		* Changes in "Based On" class properties:
		*	AutoSize:				.T.
		*	BackStyle:				0 (Transparent)
		*	Value:					.F. since checkboxes usually are used for logical
		*							values
		*
		* Changes in "Based On" class methods:
		*	Destroy:				nukes member objects
		*	Error:					calls the parent Error method so error handling
		*							goes up the containership hierarchy
		*	Init:					ensure the object is wide enough to display the
		*							caption by resetting AutoSize
		*	InteractiveChange:		call This.AnyChange()
		*	ProgrammaticChange:		call This.AnyChange()
		*	RightClick:				call This.ShowMenu()
		*	Valid:					prevent validation code from executing if the user
		*							is cancelling, retain focus if a field rule failed,
		*							and call the custom Validation() method
		*	When:					prevent the control from receiving focus in a
		*							read-only column
		*
		* Custom public properties added:
		*	Builder:				holds the name of a custom builder
		*	BuilderX:				holds the name of the preferred custom builder
		*	lUseFormShortcutMenu:	.T. if the form's shortcut menu items should be
		*							included with this object's
		*	oHook:					a reference to a hooked object (default = .NULL.)
		*	oMenu:					a reference to an SFShortcutMenu object (default =
		*							.NULL.)
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	About:					provides documentation for the class
		*	AnyChange:				called by InteractiveChange() and
		*							ProgrammaticChange()
		*	Release:				releases the object
		*	ShortcutMenu:			populates the shortcut menu
		*	ShowMenu:				display a shortcut menu
		*	Validation:				abstract method for custom validation code
		*
		* Custom protected methods added:
		*	UpdateControlSource:	updates the ControlSource with the new value
		*==============================================================================
		
	ENDPROC

	PROCEDURE anychange		&& Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place.
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		This.oMenu = .NULL.
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	03/04/2000
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local laError[1], ;
			lcName, ;
			lcMethod, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcSource, ;
			lcMessage, ;
			lnChoice
		
		* Get information about the error.
		
		aerror(laError)
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, tnLine, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(tnError, lcMethod, tnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, tnLine, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(tnError, lcMethod, tnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',tnError')
				lcError = strtran(lcError, ' ERROR()',  ' tnError')
				lcError = strtran(lcError, 'LINENO()',  'tnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + ltrim(str(tnError)) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(tnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					ltrim(str(tnLine)) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
					'Choose Yes to display the debugger, No to continue ' + ;
					'without the debugger, or Cancel to cancel execution', ;
					MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE Init
		* Ensure the object is wide enough to display the caption by resetting
		* AutoSize.
		
		with This
			if .AutoSize
				.AutoSize = .T.
			endif .AutoSize
		endwith
		
	ENDPROC

	PROCEDURE InteractiveChange
		* Call a common method for handling changes.
		
		This.AnyChange()
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		* Call a common method for handling changes.
		
		This.AnyChange()
		
	ENDPROC

	PROCEDURE release		&& Releases the object.
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	12/11/98
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	02/10/2000
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	MAKEOBJECT.PRG and SFMENU.VCX can be found (and VARTYPE.PRG
		*						in VFP 5)
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			if vartype(.oMenu) <> 'O'
				.oMenu = MakeObject('SFShortcutMenu', 'SFMENU.VCX')
			endif vartype(.oMenu) <> 'O'
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

	PROCEDURE updatecontrolsource		&& Updates the ControlSource with the new value
		*==============================================================================
		* Method:			UpdateControlSource
		* Status:			Protected
		* Purpose:			Updates the ControlSource with the new value
		* Author:			Doug Hennig
		* Copyright:		(c) 2001 Stonefield Systems Group Inc.
		* Last revision:	01/24/2001
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the ControlSource may have been updated
		*==============================================================================
		
		local lnPos, ;
			lcAlias, ;
			lcField
		with This
			lnPos = at('.', .ControlSource)
			if lnPos > 0 and not .Value == evaluate(.ControlSource)
				lcAlias = left(.ControlSource, lnPos - 1)
				lcField = substr(.ControlSource, lnPos + 1)
				if used(lcAlias)
					replace (lcField) with .Value in (lcAlias)
				else
					store .Value to (.ControlSource)
				endif used(lcAlias)
			endif lnPos > 0 ...
		endwith
		
	ENDPROC

	PROCEDURE Valid
		*==============================================================================
		* Method:			Valid
		* Status:			Public
		* Purpose:			Validate the Value
		* Author:			Doug Hennig
		* Copyright:		(c) 1996, 2000 Stonefield Systems Group Inc.
		* Last revision:	08/30/2000
		* Parameters:		none
		* Returns:			.T. if the validation succeeded or we're not doing the
		*						validation
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		* If the Valid method is fired because the user clicked on a button with the
		* Cancel property set to .T. or if the button has an lCancel property (which
		* is part of the SFCommandButton base class) and it's .T., or if we're closing
		* the form, don't bother doing the rest of the validation.
		
		local loObject
		loObject = sys(1270)
		if (type('loObject.Cancel') = 'L' and loObject.Cancel) or ;
			(type('loObject.lCancel') = 'L' and loObject.lCancel) or ;
			(type('Thisform.ReleaseType') = 'N' and Thisform.ReleaseType > 0)
			return .T.
		endif (type('loObject.lCancel') = 'L' ...
		
		* If the user tries to leave this control but a field validation rule failed,
		* we'll prevent them from doing so.
		
		if type('Thisform.lFieldRuleFailed') = 'L' and Thisform.lFieldRuleFailed
			Thisform.lFieldRuleFailed = .F.
			return 0
		endif type('Thisform.lFieldRuleFailed') = 'L' ...
		
		* Do the custom validation (this allows the developer to put custom validation
		* code into the Validation method rather than having to use code like the
		* following in the Valid method:
		*
		* dodefault()
		* custom code here
		* nodefault
		
		return This.Validation()
		
	ENDPROC

	PROCEDURE validation		&& Abstract method for custom validation code
		*==============================================================================
		* Method:			UpdateControlSource
		* Status:			Protected
		* Purpose:			Updates the ControlSource with the new value
		* Author:			Doug Hennig
		* Copyright:		(c) 2001 Stonefield Systems Group Inc.
		* Last revision:	01/24/2001
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the ControlSource may have been updated
		*==============================================================================
		
		local lnPos, ;
			lcAlias, ;
			lcField
		with This
			lnPos = at('.', .ControlSource)
			if lnPos > 0 and not .Value == evaluate(.ControlSource)
				lcAlias = left(.ControlSource, lnPos - 1)
				lcField = substr(.ControlSource, lnPos + 1)
				if used(lcAlias)
					replace (lcField) with .Value in (lcAlias)
				else
					store .Value to (.ControlSource)
				endif used(lcAlias)
			endif lnPos > 0 ...
		endwith
		
	ENDPROC

	PROCEDURE When
		* Prevent the checkbox from receiving focus in a read-only column.
		
		return (upper(This.Parent.BaseClass) <> 'COLUMN' or not This.Parent.ReadOnly)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfcheckboxgraphical AS sfcheckbox OF "sfctrls.vcx" 		&& Graphical CheckBox
 	*< CLASSDATA: Baseclass="checkbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	AutoSize = .F.
	Caption = ""
	Height = 23
	Name = "sfcheckboxgraphical"
	Style = 1
	Width = 23
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:					SFGraphicalCheckBox
		* Based On:					SFCheckBox
		* Purpose:					Graphical CheckBox
		* Author:					Doug Hennig
		* Copyright:				(c) 1996 Stonefield Systems Group Inc.
		* Last revision:			03/17/98
		* Include file:				none
		*
		* Changes in "Based On" class properties:
		*	AutoSize:				.F.
		*	Caption:				None
		*	Height:					23
		*	Style:					1 (Graphical)
		*	Width:					23
		*
		* Changes in "Based On" class methods:
		*	None
		*
		* Custom public properties added:
		*	None
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	None
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfcombobox AS combobox 		&& Base class for ComboBox objects
 	*< CLASSDATA: Baseclass="combobox" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: anychange		&& Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place.
		*m: release		&& Releases the object.
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*m: validation		&& An abstract method for custom validation code.
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class.
		*p: builderx		&& Holds the name of the preferred custom builder
		*p: lrequeryoninit		&& .T. to call Requery() from Init()
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to an SFShortcutMenu object
		*a: aitems[1,0]		&& An array that can hold the values used for the ComboBox when RowSourceType is 5.
	*</DefinedPropArrayMethod>

	BoundTo = .T.
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class.
	builderx = ( home() + 'wizards\builderd, builderdform')		&& Holds the name of the preferred custom builder
	ItemTips = .T.
	lrequeryoninit = .T.		&& .T. to call Requery() from Init()
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Name = "sfcombobox"
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to an SFShortcutMenu object
	RowSource = "This.aItems"
	RowSourceType = 5
	SelectOnEntry = .T.
	Style = 2
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:					SFComboBox
		* Based On:					ComboBox
		* Purpose:					Base class for all ComboBox objects
		* Author:					Doug Hennig
		* Copyright:				(c) 1996-2001 Stonefield Systems Group Inc.
		* Last revision:			10/11/2001
		* Include file:				SFCTRLS.H
		*
		* Changes in "Based On" class properties:
		*	BoundTo:				.T.
		*	ItemTips:				.T.
		*	RowSource:				This.aItems (see below)
		*	RowSourceType:			5 (Array)
		*	SelectOnEntry:			.T.
		*	Style:					2 (Dropdown List) because this is what we usually
		*							use
		*
		* Changes in "Based On" class methods:
		*	Destroy:				nukes member objects
		*	Error:					calls the parent Error method so error handling
		*							goes up the containership hierarchy
		*	Init:					initialize This.aItems to blanks and call
		*							This.Requery() if This.lRequeryOnInit is .T.
		*	InteractiveChange:		call This.AnyChange()
		*	ProgrammaticChange:		call This.AnyChange()
		*	Requery:				handle RowSourceType = 0-None or 1-Value when
		*								This.aItems contains the array of values
		*	RightClick:				call This.ShowMenu()
		*	Valid:					prevent validation code from executing if the user
		*							is cancelling, retain focus if a field rule failed,
		*							and call the custom Validation() method
		*
		* Custom public properties added:
		*	aItems[1]:				an array that can hold the values used for the
		*							ComboBox when RowSourceType is 5
		*	Builder:				holds the name of a custom builder
		*	BuilderX:				holds the name of the preferred custom builder
		*	lRequeryOnInit:			.T. to call Requery() from Init()
		*	lUseFormShortcutMenu:	.T. if the form's shortcut menu items should be
		*							included with this object's
		*	oHook:					a reference to a hooked object (default = .NULL.)
		*	oMenu:					a reference to an SFShortcutMenu object (default =
		*							.NULL.)
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	About:					provides documentation for the class
		*	AnyChange:				called by InteractiveChange() and
		*							ProgrammaticChange()
		*	Release:				releases the object
		*	ShortcutMenu:			populates the shortcut menu
		*	ShowMenu:				display a shortcut menu
		*	Validation:				abstract method for custom validation code
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE anychange		&& Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place.
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		This.oMenu = .NULL.
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Copyright:		(c) 1996, 2000 Stonefield Systems Group Inc.
		* Last revision:	03/04/2000
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local laError[1], ;
			lcName, ;
			lcMethod, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcSource, ;
			lcMessage, ;
			lnChoice
		
		* Get information about the error.
		
		aerror(laError)
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, tnLine, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(tnError, lcMethod, tnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, tnLine, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(tnError, lcMethod, tnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',tnError')
				lcError = strtran(lcError, ' ERROR()',  ' tnError')
				lcError = strtran(lcError, 'LINENO()',  'tnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + ltrim(str(tnError)) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(tnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					ltrim(str(tnLine)) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
					'Choose Yes to display the debugger, No to continue ' + ;
					'without the debugger, or Cancel to cancel execution', ;
					MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE Init
		with This
		
		* Call Requery() if we're supposed to; otherwise, initialize aItems to a blank
		* string.
		
			if .lRequeryOnInit
				.Requery()
			else
				.aItems = ''
			endif .lRequeryOnInit
		endwith
		
	ENDPROC

	PROCEDURE InteractiveChange
		* Call a common method for handling changes.
		
		This.AnyChange()
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		* Call a common method for handling changes.
		
		This.AnyChange()
		
	ENDPROC

	PROCEDURE release		&& Releases the object.
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE Requery
		* If RowSource is 0-None or 1-Value but aItems contains values, use AddItem (in
		* the case of 0-None) or set RowSource to a comma-delimited list of values (in
		* the case of 1-Value)from aItems. This allows disabled lines using a prompt of
		* "\-".
		
		lparameters tlNoAction
		local llColumn, ;
			lnI, ;
			lcItem
		with This
			if not tlNoAction and inlist(.RowSourceType, 0, 1) and ;
				vartype(.aItems[1]) = 'C' and (not empty(.aItems[1]) or ;
				alen(.aItems, 1) > 0)
				.RowSource = ''
				llColumn   = alen(.aItems, 2) > 0
				for lnI = 1 to alen(.aItems, 1)
					lcItem = iif(llColumn, .aItems[lnI, 1], .aItems[lnI])
					if .RowSourceType = 0
						.AddItem(lcItem)
					else
						.RowSource = .RowSource + iif(lnI = 1, '', ',') + lcItem
					endif .RowSourceType = 0
				next lnI
			endif not tlNoAction ...
		endwith
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Copyright:		(c) 1996, 2000 Stonefield Systems Group Inc.
		* Last revision:	11/16/2000
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		if This.Style = 0
			with toMenu
				.AddMenuBar('Cu\<t',   "sys(1500, '_MED_CUT',   '_MEDIT')", , , , ;
					'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly')
				.AddMenuBar('\<Copy',  "sys(1500, '_MED_COPY',  '_MEDIT')")
				.AddMenuBar('\<Paste', "sys(1500, '_MED_PASTE', '_MEDIT')", , , , ;
					'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly')
				.AddMenuBar('Cle\<ar', "sys(1500, '_MED_CLEAR', '_MEDIT')", , , , ;
					'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly')
				.AddMenuSeparator()
				.AddMenuBar('Se\<lect All', "sys(1500, '_MED_SLCTA', '_MEDIT')")
			endwith
		endif This.Style = 0
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Copyright:		(c) 1996, 2000 Stonefield Systems Group Inc.
		* Last revision:	02/10/2000
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	MAKEOBJECT.PRG and SFMENU.VCX can be found (and VARTYPE.PRG
		*						in VFP 5)
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			if vartype(.oMenu) <> 'O'
				.oMenu = MakeObject('SFShortcutMenu', 'SFMENU.VCX')
			endif vartype(.oMenu) <> 'O'
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

	PROCEDURE Valid
		*==============================================================================
		* Method:			Valid
		* Status:			Public
		* Purpose:			Validate the Value
		* Author:			Doug Hennig
		* Copyright:		(c) 1996, 2000 Stonefield Systems Group Inc.
		* Last revision:	08/30/2000
		* Parameters:		none
		* Returns:			.T. if the validation succeeded or we're not doing the
		*						validation
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		* If the Valid method is fired because the user clicked on a button with the
		* Cancel property set to .T. or if the button has an lCancel property (which
		* is part of the SFCommandButton base class) and it's .T., or if we're closing
		* the form, don't bother doing the rest of the validation.
		
		local loObject
		loObject = sys(1270)
		if (type('loObject.Cancel') = 'L' and loObject.Cancel) or ;
			(type('loObject.lCancel') = 'L' and loObject.lCancel) or ;
			(type('Thisform.ReleaseType') = 'N' and Thisform.ReleaseType > 0)
			return .T.
		endif (type('loObject.lCancel') = 'L' ...
		
		* If the user tries to leave this control but a field validation rule failed,
		* we'll prevent them from doing so.
		
		if type('Thisform.lFieldRuleFailed') = 'L' and Thisform.lFieldRuleFailed
			Thisform.lFieldRuleFailed = .F.
			return 0
		endif type('Thisform.lFieldRuleFailed') = 'L' ...
		
		* Do the custom validation (this allows the developer to put custom validation
		* code into the Validation method rather than having to use code like the
		* following in the Valid method:
		*
		* dodefault()
		* custom code here
		* nodefault
		
		return This.Validation()
		
	ENDPROC

	PROCEDURE validation		&& An abstract method for custom validation code.
	ENDPROC

ENDDEFINE

DEFINE CLASS sfcommandbutton AS commandbutton 		&& Base class for CommandButton objects
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class.
		*m: mouseenter
		*m: mouseleave
		*m: release		&& Releases the object.
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class.
		*p: builderx		&& Holds the name of the preferred custom builder
		*p: lcancel		&& .T. if this is used as a "cancel" button.
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to an SFShortcutMenu object
	*</DefinedPropArrayMethod>

	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class.
	builderx = ( home() + 'wizards\builderd, builderdform')		&& Holds the name of the preferred custom builder
	Caption = "Command1"
	Height = 27
	lcancel = .F.		&& .T. if this is used as a "cancel" button.
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Name = "sfcommandbutton"
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to an SFShortcutMenu object
	Width = 84
	
	PROCEDURE about		&& Provides documentation for the class.
		*==============================================================================
		* Class:					SFCommandButton
		* Based On:					CommandButton
		* Purpose:					Base class for all CommandButton objects
		* Author:					Doug Hennig
		* Copyright:				(c) 1996 Stonefield Systems Group Inc.
		* Last revision:			03/04/2000
		* Include file:				SFCTRLS.H
		*
		* Changes in "Based On" class properties:
		*	None
		*
		* Changes in "Based On" class methods:
		*	Destroy:				nukes member objects
		*	Error:					calls the parent Error method so error handling
		*							goes up the containership hierarchy
		*	RightClick:				call This.ShowMenu()
		*
		* Custom public properties added:
		*	Builder:				holds the name of a custom builder
		*	BuilderX:				holds the name of the preferred custom builder
		*	lCancel:				.T. if this button is used as a "cancel" button
		*							(this allows the Valid of a control to not bother
		*							doing validation if the user clicked a "cancel"
		*							button)
		*	lUseFormShortcutMenu:	.T. if the form's shortcut menu items should be
		*							included with this object's
		*	oHook:					a reference to a hooked object (default = .NULL.)
		*	oMenu:					a reference to an SFShortcutMenu object (default =
		*							.NULL.)
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	About:					provides documentation for the class
		*	Release:				releases the object
		*	ShortcutMenu:			populates the shortcut menu
		*	ShowMenu:				display a shortcut menu
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		This.oMenu = .NULL.
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	03/04/2000
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local laError[1], ;
			lcName, ;
			lcMethod, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcSource, ;
			lcMessage, ;
			lnChoice
		
		* Get information about the error.
		
		aerror(laError)
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, tnLine, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(tnError, lcMethod, tnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, tnLine, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(tnError, lcMethod, tnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',tnError')
				lcError = strtran(lcError, ' ERROR()',  ' tnError')
				lcError = strtran(lcError, 'LINENO()',  'tnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + ltrim(str(tnError)) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(tnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					ltrim(str(tnLine)) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
					'Choose Yes to display the debugger, No to continue ' + ;
					'without the debugger, or Cancel to cancel execution', ;
					MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE mouseenter
	ENDPROC

	PROCEDURE mouseleave
	ENDPROC

	PROCEDURE release		&& Releases the object.
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	12/11/98
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	02/10/2000
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	MAKEOBJECT.PRG and SFMENU.VCX can be found (and VARTYPE.PRG
		*						in VFP 5)
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			if vartype(.oMenu) <> 'O'
				.oMenu = MakeObject('SFShortcutMenu', 'SFMENU.VCX')
			endif vartype(.oMenu) <> 'O'
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfcommandgroup AS commandgroup 		&& Base class for CommandGroup objects
 	*< CLASSDATA: Baseclass="commandgroup" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class.
		*m: enabled_assign
		*m: release		&& Releases the object.
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class.
		*p: builderx		&& Holds the name of the preferred custom builder
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to an SFShortcutMenu object
	*</DefinedPropArrayMethod>

	BackStyle = 0
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class.
	builderx = ( home() + 'wizards\builderd, builderdform')		&& Holds the name of the preferred custom builder
	ButtonCount = 2
	Height = 66
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Name = "sfcommandgroup"
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to an SFShortcutMenu object
	Width = 94
	Command1.Caption = "Command1"
	Command1.Height = 27
	Command1.Left = 5
	Command1.Name = "Command1"
	Command1.Top = 5
	Command1.Width = 84
	Command2.Caption = "Command2"
	Command2.Height = 27
	Command2.Left = 5
	Command2.Name = "Command2"
	Command2.Top = 34
	Command2.Width = 84
	
	PROCEDURE about		&& Provides documentation for the class.
		*==============================================================================
		* Class:					SFCommandGroup
		* Based On:					CommandGroup
		* Purpose:					Base class for all CommandGroup objects
		* Author:					Doug Hennig
		* Copyright:				(c) 1996 Stonefield Systems Group Inc.
		* Last revision:			03/04/2000
		* Include file:				SFCTRLS.H
		*
		* Changes in "Based On" class properties:
		*	BackStyle:				0 (Transparent)
		*
		* Changes in "Based On" class methods:
		*	Destroy:				nukes member objects
		*	Error:					calls the parent Error method so error handling
		*							goes up the containership hierarchy
		*	RightClick:				call This.ShowMenu()
		*
		* Custom public properties added:
		*	Builder:				holds the name of a custom builder
		*	BuilderX:				holds the name of the preferred custom builder
		*	lUseFormShortcutMenu:	.T. if the form's shortcut menu items should be
		*							included with this object's
		*	oHook:					a reference to a hooked object (default = .NULL.)
		*	oMenu:					a reference to an SFShortcutMenu object (default =
		*							.NULL.)
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	About:					provides documentation for the class
		*	Enabled_Access:			sets the Enabled property of the object and all
		*							member objects to the specified value so all
		*							objects appear to be enabled or disabled
		*	Release:				releases the object
		*	ShortcutMenu:			populates the shortcut menu
		*	ShowMenu:				display a shortcut menu
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		This.oMenu = .NULL.
		
	ENDPROC

	PROCEDURE enabled_assign
		* Enable or disabled member objects.
		
		lparameters tlEnabled
		This.SetAll('Enabled', tlEnabled)
		This.Enabled = tlEnabled
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	03/04/2000
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local laError[1], ;
			lcName, ;
			lcMethod, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcSource, ;
			lcMessage, ;
			lnChoice
		
		* Get information about the error.
		
		aerror(laError)
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, tnLine, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(tnError, lcMethod, tnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, tnLine, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(tnError, lcMethod, tnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',tnError')
				lcError = strtran(lcError, ' ERROR()',  ' tnError')
				lcError = strtran(lcError, 'LINENO()',  'tnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + ltrim(str(tnError)) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(tnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					ltrim(str(tnLine)) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
					'Choose Yes to display the debugger, No to continue ' + ;
					'without the debugger, or Cancel to cancel execution', ;
					MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE release		&& Releases the object.
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	12/11/98
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	02/10/2000
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	MAKEOBJECT.PRG and SFMENU.VCX can be found (and VARTYPE.PRG
		*						in VFP 5)
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			if vartype(.oMenu) <> 'O'
				.oMenu = MakeObject('SFShortcutMenu', 'SFMENU.VCX')
			endif vartype(.oMenu) <> 'O'
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfcontainer AS container 		&& Base class for Container objects
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class.
		*m: calledfromthisclass		&& Returns .T. if a method was called from this class
		*m: enabled_assign
		*m: release		&& Releases the object.
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class.
		*p: builderx		&& Holds the name of the preferred custom builder
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to an SFShortcutMenu object
	*</DefinedPropArrayMethod>

	BackStyle = 0
	BorderWidth = 0
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class.
	builderx = ( home() + 'wizards\builderd, builderdform')		&& Holds the name of the preferred custom builder
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Name = "sfcontainer"
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to an SFShortcutMenu object
	
	PROCEDURE about		&& Provides documentation for the class.
		*==============================================================================
		* Class:					SFContainer
		* Based On:					Container
		* Purpose:					Base class for all Container objects
		* Author:					Doug Hennig
		* Copyright:				(c) 1996-2001 Stonefield Systems Group Inc.
		* Last revision:			09/27/2001
		* Include file:				SFCTRLS.H
		*
		* Changes in "Based On" class properties:
		*	BackStyle:				0 (Transparent)
		*	BorderWidth:			0
		*
		* Changes in "Based On" class methods:
		*	Destroy:				nukes member objects
		*	Error:					calls the parent Error method so error handling
		*							goes up the containership hierarchy
		*	RightClick:				call This.ShowMenu()
		*
		* Custom public properties added:
		*	Builder:				holds the name of a custom builder
		*	BuilderX:				holds the name of the preferred custom builder
		*	lUseFormShortcutMenu:	.T. if the form's shortcut menu items should be
		*							included with this object's
		*	oHook:					a reference to a hooked object (default = .NULL.)
		*	oMenu:					a reference to an SFShortcutMenu object (default =
		*							.NULL.)
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	About:					provides documentation for the class
		*	Enabled_Access:			sets the Enabled property of the object and all
		*							member objects to the specified value so all
		*							objects appear to be enabled or disabled
		*	Release:				releases the object
		*	ShortcutMenu:			populates the shortcut menu
		*	ShowMenu:				display a shortcut menu
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROTECTED PROCEDURE calledfromthisclass		&& Returns .T. if a method was called from this class
		*==============================================================================
		* Method:			CalledFromThisClass
		* Status:			Protected
		* Purpose:			Determines if the method that called this method was called
		*						from a method of this class or an ancestor
		* Author:			Doug Hennig
		* Copyright:		(c) 1998, 2000 Stonefield Systems Group Inc.
		* Last Revision:	09/27/2001
		* Parameters:		none
		* Returns:			.T. if the method that called this method was called from a
		*						method of this class or an ancestor
		* Environment in:	none
		* Environment out:	none
		* Notes:			The reason we want to know if the method that called this
		*						method was called from a method of this class or not is
		*						to permit "read-only" properties to be changed only by
		*						methods of this class. This would typically be called
		*						from an Assign method, such as:
		*
		*					lparameters tuNewValue
		*					if This.CalledFromThisClass()
		*						This.<property> = tuNewValue
		*					else
		*						error 1743, '<property>'   && property is read-only
		*					endif This.CalledFromThisClass()
		*==============================================================================
		
		local lnLevel, ;
			lcProgram, ;
			lcObject, ;
			loParent, ;
			laClasses[1], ;
			lnClasses, ;
			lnI, ;
			llReturn, ;
			lcThisName
		
		* Get the name of the program that called us, and get the object name from it.
		* Set loParent to our parent if there is one.
		
		lnLevel   = program(-1)
		lcProgram = iif(lnLevel > 2, upper(program(lnLevel - 2)), '')
		lcObject  = left(lcProgram, rat('.', lcProgram) - 1)
		loParent  = iif(type('This.Parent') = 'O', This.Parent, .NULL.)
		
		* Check our class hierarchy to see if we were called from ourselves or an
		* ancester method.
		
		lnClasses = aclass(laClasses, This)
		for lnI = 1 to lnClasses
			if lcObject == upper(laClasses[lnI])
				llReturn = .T.
				exit
			endif lcObject == upper(laClasses[lnI])
		next lnI
		
		* If we didn't come from ourselves or an ancestor and we have a parent, our
		* name may not match our class, so check the containership hierarchy.
		
		if not llReturn and not isnull(loParent)
			lcThisName = This.Name
			do while vartype(loParent) = 'O'
				lcThisName = loParent.Name + '.' + lcThisName
				loParent   = iif(type('loParent.Parent') = 'O', loParent.Parent, ;
					.NULL.)
			enddo while vartype(loParent) = 'O'
			llReturn = upper(lcObject) == upper(lcThisName)
		endif not llReturn ...
		return llReturn
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		This.oMenu = .NULL.
		
	ENDPROC

	PROCEDURE enabled_assign
		* Enable or disabled member objects.
		
		lparameters tlEnabled
		This.SetAll('Enabled', tlEnabled)
		This.Enabled = tlEnabled
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	03/04/2000
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local laError[1], ;
			lcName, ;
			lcMethod, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcSource, ;
			lcMessage, ;
			lnChoice
		
		* Get information about the error.
		
		aerror(laError)
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, tnLine, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(tnError, lcMethod, tnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, tnLine, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(tnError, lcMethod, tnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',tnError')
				lcError = strtran(lcError, ' ERROR()',  ' tnError')
				lcError = strtran(lcError, 'LINENO()',  'tnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + ltrim(str(tnError)) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(tnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					ltrim(str(tnLine)) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
					'Choose Yes to display the debugger, No to continue ' + ;
					'without the debugger, or Cancel to cancel execution', ;
					MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE release		&& Releases the object.
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	12/11/98
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	02/10/2000
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	MAKEOBJECT.PRG and SFMENU.VCX can be found (and VARTYPE.PRG
		*						in VFP 5)
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			if vartype(.oMenu) <> 'O'
				.oMenu = MakeObject('SFShortcutMenu', 'SFMENU.VCX')
			endif vartype(.oMenu) <> 'O'
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfcontrol AS control 		&& Base class for Control objects
 	*< CLASSDATA: Baseclass="control" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class.
		*m: enabled_assign
		*m: release		&& Releases the object.
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class.
		*p: builderx		&& Holds the name of the preferred custom builder
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to an SFShortcutMenu object
	*</DefinedPropArrayMethod>

	BackStyle = 0
	BorderWidth = 0
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class.
	builderx = ( home() + 'wizards\builderd, builderdform')		&& Holds the name of the preferred custom builder
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Name = "sfcontrol"
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to an SFShortcutMenu object
	
	PROCEDURE about		&& Provides documentation for the class.
		*==============================================================================
		* Class:					SFControl
		* Based On:					Control
		* Purpose:					Base class for all Controlobjects
		* Author:					Doug Hennig
		* Copyright:				(c) 1996 Stonefield Systems Group Inc.
		* Last revision:			03/04/2000
		* Include file:				SFCTRLS.H
		*
		* Changes in "Based On" class properties:
		*	BackStyle:				0 (Transparent)
		*	BorderWidth:			0
		*
		* Changes in "Based On" class methods:
		*	Destroy:				nukes member objects
		*	Error:					calls the parent Error method so error handling
		*							goes up the containership hierarchy
		*	RightClick:				call This.ShowMenu()
		*
		* Custom public properties added:
		*	Builder:				holds the name of a custom builder
		*	BuilderX:				holds the name of the preferred custom builder
		*	lUseFormShortcutMenu:	.T. if the form's shortcut menu items should be
		*							included with this object's
		*	oHook:					a reference to a hooked object (default = .NULL.)
		*	oMenu:					a reference to an SFShortcutMenu object (default =
		*							.NULL.)
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	About:					provides documentation for the class
		*	Enabled_Access:			sets the Enabled property of the object and all
		*							member objects to the specified value so all
		*							objects appear to be enabled or disabled
		*	Release:				releases the object
		*	ShortcutMenu:			populates the shortcut menu
		*	ShowMenu:				display a shortcut menu
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		This.oMenu = .NULL.
		
	ENDPROC

	PROCEDURE enabled_assign
		* Enable or disabled member objects.
		
		lparameters tlEnabled
		This.SetAll('Enabled', tlEnabled)
		This.Enabled = tlEnabled
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	03/04/2000
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local laError[1], ;
			lcName, ;
			lcMethod, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcSource, ;
			lcMessage, ;
			lnChoice
		
		* Get information about the error.
		
		aerror(laError)
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, tnLine, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(tnError, lcMethod, tnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, tnLine, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(tnError, lcMethod, tnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',tnError')
				lcError = strtran(lcError, ' ERROR()',  ' tnError')
				lcError = strtran(lcError, 'LINENO()',  'tnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + ltrim(str(tnError)) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(tnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					ltrim(str(tnLine)) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
					'Choose Yes to display the debugger, No to continue ' + ;
					'without the debugger, or Cancel to cancel execution', ;
					MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE release		&& Releases the object.
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	12/11/98
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	02/10/2000
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	MAKEOBJECT.PRG and SFMENU.VCX can be found (and VARTYPE.PRG
		*						in VFP 5)
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			if vartype(.oMenu) <> 'O'
				.oMenu = MakeObject('SFShortcutMenu', 'SFMENU.VCX')
			endif vartype(.oMenu) <> 'O'
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfcustom AS custom 		&& Base class for Custom objects
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: calledfromthisclass		&& Return .T. if a method was called from this class
		*m: cleanup		&& Cleans up member references when the object is released or destroyed
		*m: release		&& Releases the object.
		*m: releasemembers		&& Abstract method to nuke member references
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class.
		*p: builderx		&& Holds the name of the preferred custom builder
		*p: lrelease		&& .T. as the object is being released
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to an SFShortcutMenu object
	*</DefinedPropArrayMethod>

	PROTECTED lrelease
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class.
	builderx = ( home() + 'wizards\builderd, builderdform')		&& Holds the name of the preferred custom builder
	lrelease = .F.		&& .T. as the object is being released
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Name = "sfcustom"
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to an SFShortcutMenu object
	Width = 17
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:					SFCustom
		* Based On:					Custom
		* Purpose:					Base class for all Custom objects
		* Author:					Doug Hennig
		* Copyright:				(c) 1996-2001 Stonefield Systems Group Inc.
		* Last revision:			09/27/2001
		* Include file:				SFCTRLS.H
		*
		* Changes in "Based On" class properties:
		*	Width:					17 so the object is small when dropped on a form
		*
		* Changes in "Based On" class methods:
		*	Destroy:				cleanup as the object is destroyed
		*	Error:					calls the parent Error method so error handling
		*							goes up the containership hierarchy
		*
		* Custom public properties added:
		*	Builder:				holds the name of a custom builder
		*	BuilderX:				holds the name of the preferred custom builder
		*	lUseFormShortcutMenu:	.T. if the form's shortcut menu items should be
		*							included with this object's
		*	oHook:					a reference to a hooked object (default = .NULL.)
		*	oMenu:					a reference to an SFShortcutMenu object (default =
		*							.NULL.)
		*
		* Custom protected properties added:
		*	lRelease:				.T. as the object is being released
		*
		* Custom public methods added:
		*	About:					provides documentation for the class
		*	Release:				releases the object
		*	ReleaseMembers:			abstract method to nuke member references
		*	ShortcutMenu:			populates the shortcut menu
		*	ShowMenu:				display a shortcut menu
		*
		* Custom protected methods added:
		*	CalledFromThisClass:	returns .T. if a method was called from this class
		*	Cleanup:				cleans up member references when the object is
		*							released or destroyed
		*==============================================================================
		
	ENDPROC

	PROTECTED PROCEDURE calledfromthisclass		&& Return .T. if a method was called from this class
		*==============================================================================
		* Method:			CalledFromThisClass
		* Status:			Protected
		* Purpose:			Determines if the method that called this method was called
		*						from a method of this class or an ancestor
		* Author:			Doug Hennig
		* Copyright:		(c) 1998, 2000 Stonefield Systems Group Inc.
		* Last Revision:	09/27/2001
		* Parameters:		none
		* Returns:			.T. if the method that called this method was called from a
		*						method of this class or an ancestor
		* Environment in:	none
		* Environment out:	none
		* Notes:			The reason we want to know if the method that called this
		*						method was called from a method of this class or not is
		*						to permit "read-only" properties to be changed only by
		*						methods of this class. This would typically be called
		*						from an Assign method, such as:
		*
		*					lparameters tuNewValue
		*					if This.CalledFromThisClass()
		*						This.<property> = tuNewValue
		*					else
		*						error 1743, '<property>'   && property is read-only
		*					endif This.CalledFromThisClass()
		*==============================================================================
		
		local lnLevel, ;
			lcProgram, ;
			lcObject, ;
			loParent, ;
			laClasses[1], ;
			lnClasses, ;
			lnI, ;
			llReturn, ;
			lcThisName
		
		* Get the name of the program that called us, and get the object name from it.
		* Set loParent to our parent if there is one.
		
		lnLevel   = program(-1)
		lcProgram = iif(lnLevel > 2, upper(program(lnLevel - 2)), '')
		lcObject  = left(lcProgram, rat('.', lcProgram) - 1)
		loParent  = iif(type('This.Parent') = 'O', This.Parent, .NULL.)
		
		* Check our class hierarchy to see if we were called from ourselves or an
		* ancester method.
		
		lnClasses = aclass(laClasses, This)
		for lnI = 1 to lnClasses
			if lcObject == upper(laClasses[lnI])
				llReturn = .T.
				exit
			endif lcObject == upper(laClasses[lnI])
		next lnI
		
		* If we didn't come from ourselves or an ancestor and we have a parent, our
		* name may not match our class, so check the containership hierarchy.
		
		if not llReturn and not isnull(loParent)
			lcThisName = This.Name
			do while vartype(loParent) = 'O'
				lcThisName = loParent.Name + '.' + lcThisName
				loParent   = iif(type('loParent.Parent') = 'O', loParent.Parent, ;
					.NULL.)
			enddo while vartype(loParent) = 'O'
			llReturn = upper(lcObject) == upper(lcThisName)
		endif not llReturn ...
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE cleanup		&& Cleans up member references when the object is released or destroyed
		*==============================================================================
		* Method:			Cleanup
		* Status:			Protected
		* Purpose:			Nuke member objects
		* Author:			Doug Hennig
		* Copyright:		(c) 1998 Stonefield Systems Group Inc.
		* Last Revision:	03/24/99
		* Parameters:		none
		* Returns:			.T. if everything succeeded
		* Environment in:	This.lRelease is .T. if we're already in the process of
		*						releasing
		* Environment out:	This.lRelease is .T.
		*					This.oHook is .NULL.
		*					This.ReleaseMembers() was called
		* Notes:			This methods avoids use of "with This" to prevent potential
		*						problems with dangling object references
		*==============================================================================
		
		if This.lRelease
			return .F.
		endif This.lRelease
		This.lRelease = .T.
		This.ReleaseMembers()
		This.oHook = .NULL.
		This.oMenu = .NULL.
		
	ENDPROC

	PROCEDURE Destroy
		* Cleanup as the object is destroyed.
		
		This.Cleanup()
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	03/04/2000
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local laError[1], ;
			lcName, ;
			lcMethod, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcSource, ;
			lcMessage, ;
			lnChoice
		
		* Get information about the error.
		
		aerror(laError)
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, tnLine, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(tnError, lcMethod, tnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, tnLine, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(tnError, lcMethod, tnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',tnError')
				lcError = strtran(lcError, ' ERROR()',  ' tnError')
				lcError = strtran(lcError, 'LINENO()',  'tnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + ltrim(str(tnError)) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(tnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					ltrim(str(tnLine)) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
					'Choose Yes to display the debugger, No to continue ' + ;
					'without the debugger, or Cancel to cancel execution', ;
					MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE release		&& Releases the object.
		* Release the object. Note the avoidance of "with This" in this code to prevent
		* potential problems with dangling object references.
		
		if This.lRelease
			nodefault
			return .F.
		endif This.lRelease
		This.Cleanup()
		release This
		
	ENDPROC

	PROCEDURE releasemembers		&& Abstract method to nuke member references
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	03/26/99
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	02/10/2000
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	MAKEOBJECT.PRG and SFMENU.VCX can be found (and VARTYPE.PRG
		*						in VFP 5)
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			if vartype(.oMenu) <> 'O'
				.oMenu = MakeObject('SFShortcutMenu', 'SFMENU.VCX')
			endif vartype(.oMenu) <> 'O'
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfeditbox AS editbox 		&& Base class for EditBox objects
 	*< CLASSDATA: Baseclass="editbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class.
		*m: anychange		&& Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place.
		*m: release		&& Releases the object.
		*m: selectfont		&& Selects the font for the control
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*m: validation		&& An abstract method for custom validation code.
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class.
		*p: builderx		&& Holds the name of the preferred custom builder
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to an SFShortcutMenu object
	*</DefinedPropArrayMethod>

	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class.
	builderx = ( home() + 'wizards\builderd, builderdform')		&& Holds the name of the preferred custom builder
	IntegralHeight = .T.
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Name = "sfeditbox"
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to an SFShortcutMenu object
	SelectOnEntry = .T.
	
	PROCEDURE about		&& Provides documentation for the class.
		*==============================================================================
		* Class:					SFEditBox
		* Based On:					EditBox
		* Purpose:					Base class for all EditBox objects
		* Author:					Doug Hennig
		* Copyright:				(c) 1996, 2000 Stonefield Systems Group Inc.
		* Last revision:			03/16/2001
		* Include file:				SFCTRLS.H
		*
		* Changes in "Based On" class properties:
		*	IntegralHeight:			.T.
		*	SelectOnEntry:			.T.
		*
		* Changes in "Based On" class methods:
		*	Destroy:				nukes member objects
		*	Error:					calls the parent Error method so error handling
		*							goes up the containership hierarchy
		*	GotFocus:				ensure the text is selected when the control
		*							receives focus with the mouse
		*	InteractiveChange:		call This.AnyChange()
		*	ProgrammaticChange:		call This.AnyChange()
		*	RightClick:				call This.ShowMenu()
		*	Valid:					prevent validation code from executing if the user
		*							is cancelling, retain focus if a field rule failed,
		*							and call the custom Validation() method
		*
		* Custom public properties added:
		*	Builder:				holds the name of a custom builder
		*	BuilderX:				holds the name of the preferred custom builder
		*	lUseFormShortcutMenu:	.T. if the form's shortcut menu items should be
		*							included with this object's
		*	oHook:					a reference to a hooked object (default = .NULL.)
		*	oMenu:					a reference to an SFShortcutMenu object (default =
		*							.NULL.)
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	About:					provides documentation for the class
		*	AnyChange:				called by InteractiveChange() and
		*							ProgrammaticChange()
		*	Release:				releases the object
		*	SelectFont:				selects the font for the control
		*	ShortcutMenu:			populates the shortcut menu
		*	ShowMenu:				display a shortcut menu
		*	Validation:				abstract method for custom validation code
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE anychange		&& Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place.
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		This.oMenu = .NULL.
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	03/04/2000
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local laError[1], ;
			lcName, ;
			lcMethod, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcSource, ;
			lcMessage, ;
			lnChoice
		
		* Get information about the error.
		
		aerror(laError)
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, tnLine, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(tnError, lcMethod, tnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, tnLine, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(tnError, lcMethod, tnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',tnError')
				lcError = strtran(lcError, ' ERROR()',  ' tnError')
				lcError = strtran(lcError, 'LINENO()',  'tnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + ltrim(str(tnError)) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(tnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					ltrim(str(tnLine)) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
					'Choose Yes to display the debugger, No to continue ' + ;
					'without the debugger, or Cancel to cancel execution', ;
					MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE GotFocus
		* Ensure the text is selected when the control receives focus with the mouse.
		
		if This.SelectOnEntry
			dodefault()
		endif This.SelectOnEntry
		
	ENDPROC

	PROCEDURE InteractiveChange
		* Call a common method for handling changes.
		
		This.AnyChange()
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		* Call a common method for handling changes.
		
		This.AnyChange()
		
	ENDPROC

	PROCEDURE release		&& Releases the object.
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE selectfont		&& Selects the font for the control
		local lcStyle, ;
			lcFont, ;
			lnPos1, ;
			lnPos2
		with This
			lcStyle = iif(.FontBold, 'B', '') + iif(.FontItalic, 'I', '')
		#if type('version(4)') = 'U'
			lcFont  = getfont()
		#else
			lcFont  = getfont(.FontName, .FontSize, lcStyle)
		#endif
			if not empty(lcFont)
				lnPos1      = at(',', lcFont, 1)
				lnPos2      = at(',', lcFont, 2)
				.FontName   = left(lcFont, lnPos1 - 1)
				.FontSize   = val(substr(lcFont, lnPos1 + 1, lnPos2 - lnPos1 - 1))
				lcFont      = substr(lcFont, lnPos2 + 1)
				.FontBold   = 'B' $ lcFont
				.FontItalic = 'I' $ lcFont
			endif not empty(lcFont)
		endwith
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Copyright:		(c) 1996, 2000 Stonefield Systems Group Inc.
		* Last revision:	03/16/2001
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		with toMenu
			.AddMenuBar('Cu\<t',   "sys(1500, '_MED_CUT',   '_MEDIT')", , , , ;
				'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly')
			.AddMenuBar('\<Copy',  "sys(1500, '_MED_COPY',  '_MEDIT')")
			.AddMenuBar('\<Paste', "sys(1500, '_MED_PASTE', '_MEDIT')", , , , ;
				'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly')
			.AddMenuBar('Cle\<ar', "sys(1500, '_MED_CLEAR', '_MEDIT')", , , , ;
				'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly')
			.AddMenuSeparator()
			.AddMenuBar('Se\<lect All', "sys(1500, '_MED_SLCTA', '_MEDIT')")
			.AddMenuSeparator()
			.AddMenuBar('\<Font...', tcObject + '.SelectFont()')
		endwith
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	02/10/2000
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	MAKEOBJECT.PRG and SFMENU.VCX can be found (and VARTYPE.PRG
		*						in VFP 5)
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			if vartype(.oMenu) <> 'O'
				.oMenu = MakeObject('SFShortcutMenu', 'SFMENU.VCX')
			endif vartype(.oMenu) <> 'O'
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

	PROCEDURE Valid
		*==============================================================================
		* Method:			Valid
		* Status:			Public
		* Purpose:			Validate the Value
		* Author:			Doug Hennig
		* Copyright:		(c) 1996, 2000 Stonefield Systems Group Inc.
		* Last revision:	08/30/2000
		* Parameters:		none
		* Returns:			.T. if the validation succeeded or we're not doing the
		*						validation
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		* If the Valid method is fired because the user clicked on a button with the
		* Cancel property set to .T. or if the button has an lCancel property (which
		* is part of the SFCommandButton base class) and it's .T., or if we're closing
		* the form, don't bother doing the rest of the validation.
		
		local loObject
		loObject = sys(1270)
		if (type('loObject.Cancel') = 'L' and loObject.Cancel) or ;
			(type('loObject.lCancel') = 'L' and loObject.lCancel) or ;
			(type('Thisform.ReleaseType') = 'N' and Thisform.ReleaseType > 0)
			return .T.
		endif (type('loObject.lCancel') = 'L' ...
		
		* If the user tries to leave this control but a field validation rule failed,
		* we'll prevent them from doing so.
		
		if type('Thisform.lFieldRuleFailed') = 'L' and Thisform.lFieldRuleFailed
			Thisform.lFieldRuleFailed = .F.
			return 0
		endif type('Thisform.lFieldRuleFailed') = 'L' ...
		
		* Do the custom validation (this allows the developer to put custom validation
		* code into the Validation method rather than having to use code like the
		* following in the Valid method:
		*
		* dodefault()
		* custom code here
		* nodefault
		
		return This.Validation()
		
	ENDPROC

	PROCEDURE validation		&& An abstract method for custom validation code.
	ENDPROC

ENDDEFINE

DEFINE CLASS sfform AS form 		&& The base class for Form objects
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: activateobjectpage		&& Ensures any page the specified object is sitting on is the active page
		*m: afterrefresh		&& An abstract method of code to execute after a form is refreshed
		*m: beforerefresh		&& An abstract method of code to execute before a form is refreshed
		*m: calledfromthisclass		&& Returns .T. if a method was called from this class
		*m: cleanup		&& Cleans up member references when the object is released or destroyed
		*m: finderrorhandler		&& Find the first parent for a specified object that has code in its Error method
		*m: handleerror		&& Handles an error
		*m: refreshform		&& Refreshes the form
		*m: releasemembers		&& Abstract method to nuke member references
		*m: reseterror		&& Resets lErrorOccurred and aErrorInfo.
		*m: seterror		&& Sets lErrorOccurred and aErrorInfo to information about the most recent error.
		*m: setfocustofirstobject		&& Sets focus to the first object in the specified container
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class.
		*p: builderx		&& Holds the name of the preferred custom builder
		*p: lerrorinfosaved		&& .T. if the error information has been saved in aErrorInfo
		*p: lerroroccurred		&& .T. if an error occurred (set in Error).
		*p: lrelease		&& .T. as the object is being released
		*p: nborderstyle		&& The value to put into the BorderStyle property at runtime.
		*p: nlasterror		&& The index to the last error that occurred in aErrorInfo.
		*p: oerror		&& A reference to an ErrorMgr object.
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& An object reference to a shortcut menu object
		*p: omessage		&& A reference to an SFMessageMgr object
		*p: outility		&& A reference to an SFUtility object
		*a: aerrorinfo[1,0]		&& An array of error information.
	*</DefinedPropArrayMethod>

	PROTECTED lerrorinfosaved,lrelease
	AutoCenter = .T.
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class.
	builderx = ( home() + 'wizards\builderd, builderdform')		&& Holds the name of the preferred custom builder
	Caption = "Form"
	DoCreate = .T.
	lerrorinfosaved = .F.		&& .T. if the error information has been saved in aErrorInfo
	lerroroccurred = .F.		&& .T. if an error occurred (set in Error).
	lrelease = .F.		&& .T. as the object is being released
	Name = "sfform"
	nborderstyle = 2		&& The value to put into the BorderStyle property at runtime.
	nlasterror = 0		&& The index to the last error that occurred in aErrorInfo.
	oerror = .NULL.		&& A reference to an ErrorMgr object.
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& An object reference to a shortcut menu object
	omessage = .NULL.		&& A reference to an SFMessageMgr object
	outility = .NULL.		&& A reference to an SFUtility object
	ShowTips = .T.
	ShowWindow = 1
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:					SFForm
		* Based On:					Form
		* Purpose:					Base class for all Form objects
		* Author:					Doug Hennig
		* Copyright:				(c) 1996, 2001 Stonefield Systems Group Inc.
		* Last revision:			02/02/2001
		* Include file:				SFCTRLS.H
		*
		* Changes in "Based On" class properties:
		*	AutoCenter:				.T.
		*	ShowTips:				.T.
		*	ShowWindow:				1 - In Top-level Form
		*
		* Changes in "Based On" class methods:
		*	Deactivate:				ensures the screen is active if visible
		*	Destroy:				hides the form so it disappears faster, and clean
		*							up other things
		*	Error:					calls This.SetError() and This.HandleError()
		*	GotFocus:				calls This.RefreshForm()
		*	Init:					puts the value of the custom nBorderStyle property
		*							into the BorderStyle property. Instantiate
		*							SFUtility and SFMessageMgr objects if necessary
		*	Load:					set up the environment the way we want
		*	Release:				call This.Cleanup()
		*	RightClick:				call This.ShowMenu()
		*	Show:					call SetFocusToFirstObject() so focus goes to the
		*							first object in the form
		*
		* Custom public properties added:
		*	aErrorInfo:				an array of error information
		*	Builder:				holds the name of a custom builder
		*	BuilderX:				holds the name of the preferred custom builder
		*	lErrorOccurred:			.T. if an error occurred (set in SetError)
		*	nBorderStyle:			the value (default = 2, Fixed dialog) to put into
		*							the BorderStyle property at runtime
		*	nLastError:				the index to the last error that occurred in
		*							aErrorInfo
		*	oError:					a reference to an error handling object (default =
		*							.NULL.)
		*	oHook:					a reference to a hooked object (default = .NULL.)
		*	oMenu:					a reference to an SFShortcutMenu object (default =
		*							.NULL.)
		*	oMessage:				a reference to an SFMessageMgr object (default =
		*							.NULL.)
		*	oUtility:				a reference to an SFUtility object (default =
		*							.NULL.)
		*
		* Custom protected properties added:
		*	lErrorInfoSaved:		.T. if the error information has been saved in
		*							aErrorInfo
		*	lRelease:				.T. as the object is being released
		*
		* Custom public methods added:
		*	About:					provides documentation for the class
		*	ActivateObjectPage:		ensures any page the specified object is sitting on
		*							is the active page
		*	AfterRefresh:			an abstract method of code to execute after a form
		*							is refreshed
		*	BeforeRefresh:			an abstract method of code to execute before a form
		*							is refreshed
		*	FindErrorHandler:		called by the Error method of contained objects to
		*							find a parent that has code in its Error method
		*	HandleError:			handles an error
		*	RefreshForm:			refreshes the form
		*	ReleaseMembers:			abstract method to nuke member references
		*	ResetError:				resets lErrorOccurred, aErrorInfo, and nLastError
		*	SetError:				sets lErrorOccurred and aErrorInfo to information
		*							about the most recent error
		*	SetFocusToFirstObject:	sets focus to the first object in the specified
		*							container
		*	ShortcutMenu:			populates the shortcut menu
		*	ShowMenu:				display a shortcut menu
		*
		* Custom protected methods added:
		*	CalledFromThisClass:	returns .T. if a method was called from this class
		*	Cleanup:				cleans up member references when the object is
		*							released or destroyed
		*==============================================================================
		
	ENDPROC

	PROCEDURE activateobjectpage		&& Ensures any page the specified object is sitting on is the active page
		*==============================================================================
		* Method:			ActivateObjectPage
		* Status:			Public
		* Purpose:			Ensures any page the specified object is sitting on is the
		*						active page
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	12/04/98
		* Parameters:		toObject - an object reference to the desired object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	any page (even if the object is in a container on a
		*						pageframe on a pageframe) the specified object is
		*						sitting on is the active page
		*==============================================================================
		
		lparameters toObject
		local loParent, ;
			lnPage
		
		* Ensure the passed parameter is a contained object.
		
		if vartype(toObject) <> 'O' or type('toObject.Parent') <> 'O'
			error 'Parameter is not a contained object.'
			return .F.
		endif vartype(toObject) <> 'O' ...
		loParent = toObject.Parent
		lnPage   = 0
		
		* Drill up until we hit the form, activating pages as necessary.
		
		do while upper(loParent.BaseClass) <> 'FORM'
			do case
				case upper(loParent.BaseClass) == 'PAGE'
					lnPage = loParent.PageOrder
				case upper(loParent.BaseClass) == 'PAGEFRAME' and ;
					loParent.ActivePage <> lnPage
					loParent.ActivePage = lnPage
			endcase
			loParent = loParent.Parent
		enddo while upper(loParent.BaseClass) <> 'FORM'
		
	ENDPROC

	PROCEDURE afterrefresh		&& An abstract method of code to execute after a form is refreshed
	ENDPROC

	PROCEDURE beforerefresh		&& An abstract method of code to execute before a form is refreshed
	ENDPROC

	PROTECTED PROCEDURE calledfromthisclass		&& Returns .T. if a method was called from this class
		*==============================================================================
		* Method:			CalledFromThisClass
		* Status:			Protected
		* Purpose:			Determines if the method that called this method was called
		*						from a method of this class or an ancestor
		* Author:			Doug Hennig
		* Copyright:		(c) 1998, 2000 Stonefield Systems Group Inc.
		* Last Revision:	08/22/2000
		* Parameters:		none
		* Returns:			.T. if the method that called this method was called from a
		*						method of this class or an ancestor
		* Environment in:	none
		* Environment out:	none
		* Notes:			The reason we want to know if the method that called this
		*						method was called from a method of this class or not is
		*						to permit "read-only" properties to be changed only by
		*						methods of this class. This would typically be called
		*						from an Assign method, such as:
		*
		*					lparameters tuNewValue
		*					if This.CalledFromThisClass()
		*						This.<property> = tuNewValue
		*					else
		*						error 1743, '<property>'   && property is read-only
		*					endif This.CalledFromThisClass()
		*==============================================================================
		
		local lnLevel, ;
			lcProgram, ;
			lcObject, ;
			laClasses[1], ;
			lnClasses, ;
			lnI, ;
			llReturn
		
		* Get the name of the program that called us, and get the object name from it.
		
		lnLevel   = program(-1)
		lcProgram = iif(lnLevel > 2, upper(program(lnLevel - 2)), '')
		lcObject  = left(lcProgram, rat('.', lcProgram) - 1)
		
		* Check our class hierarchy to see if we were called from ourselves or an
		* ancester method.
		
		lnClasses = aclass(laClasses, This)
		for lnI = 1 to lnClasses
			if lcObject == upper(laClasses[lnI])
				llReturn = .T.
				exit
			endif lcObject == upper(laClasses[lnI])
		next lnI
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE cleanup		&& Cleans up member references when the object is released or destroyed
		*==============================================================================
		* Method:			Cleanup
		* Status:			Protected
		* Purpose:			Nuke member objects
		* Author:			Doug Hennig
		* Copyright:		(c) 1998 Stonefield Systems Group Inc.
		* Last Revision:	03/04/2000
		* Parameters:		none
		* Returns:			.T. if everything succeeded
		* Environment in:	This.lRelease is .T. if we're already in the process of
		*						releasing
		* Environment out:	This.lRelease is .T.
		*					This.oHook, oError, and oMenu are .NULL.
		*					This.ReleaseMembers() was called
		* Notes:			This methods avoids use of "with This" to prevent potential
		*						problems with dangling object references
		*==============================================================================
		
		if This.lRelease
			return .F.
		endif This.lRelease
		This.lRelease = .T.
		This.ReleaseMembers()
		This.oHook    = .NULL.
		This.oError   = .NULL.
		This.oMenu    = .NULL.
		This.oMessage = .NULL.
		This.oUtility = .NULL.
		
	ENDPROC

	PROCEDURE Deactivate
		*==============================================================================
		* Method:			Deactivate
		* Status:			Public
		* Purpose:			Called when another window is activated
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	03/16/98
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	if _screen is visible, it's activated in case of BROWSE or
		*						other things that use the current form characteristics
		*==============================================================================
		
		if _screen.Visible
			activate screen
		endif _screen.Visible
		
	ENDPROC

	PROCEDURE Destroy
		*==============================================================================
		* Method:			Destroy
		* Status:			Public
		* Purpose:			Called when the object is being destroyed
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	12/11/98
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the form and any member objects are destroyed
		*					if oApp exists, its CloseForm() method is called so it
		*						knows we're no longer around
		*==============================================================================
		
		with This
		
		* Hide the form so it appears to go away faster.
		
			.Hide()
		
		* Cleanup as the object is destroyed.
		
			.Cleanup()
		
		* Tell oApp we're closing.
		
			if type('oApp.Name') = 'C' and pemstatus(oApp, 'CloseForm', 5)
				oApp.CloseForm(.Name)
			endif type('oApp.Name') = 'C' ...
		endwith
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Called when an error occurs in this object or a member
		*						object
		* Author:			Doug Hennig
		* Copyright:		(c) 1996, 2001 Stonefield Systems Group Inc.
		* Last revision:	02/02/2001
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number where the error occurred
		* Returns:			varies
		* Environment in:	an error has occurred
		* Environment out:	control may be returned to the object/method that caused
		*						the error (either as RETURN or RETRY) or to the routine
		*						containing the READ EVENTS for the application
		*					the form may be released
		*					see This.SetError() and This.HandleError() for other
		*						environmental changes
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local laError[1], ;
			lcReturn, ;
			lcReturnToOnCancel, ;
			lnPos, ;
			lcObject
		with This
		
		* Use SetError() and HandleError() to gather error information and handle it.
		
			aerror(laError)
			.SetError(tcMethod, tnLine, @laError)
			.lErrorInfoSaved = .F.
			lcReturn = .HandleError()
		
		* Figure out where to go if the user chooses "Cancel".
		
			do case
				case left(sys(16, 1), at('.', sys(16, 1)) - 1) = 'PROCEDURE ' + ;
					upper(.Name)
					lcReturnToOnCancel = ''
				case type('.oError.cReturnToOnCancel') = 'C'
					lcReturnToOnCancel = .oError.cReturnToOnCancel
				case type('oError.cReturnToOnCancel') = 'C'
					lcReturnToOnCancel = oError.cReturnToOnCancel
				otherwise
					lcReturnToOnCancel = 'MASTER'
			endcase
		endwith
		
		* Handle the return value, depending on whether the error was "ours" or came
		* from a member.
		
		lnPos    = at('.', tcMethod)
		lcObject = iif(lnPos = 0, '', upper(left(tcMethod, lnPos - 1)))
		do case
		
		* We're supposed to close the form, so do so and return to the master program
		* (we'll just cancel if we *are* the master program).
		
			case lcReturn = ccMSG_CLOSEFORM
				This.Release()
				if empty(lcReturnToOnCancel)
					cancel
				else
					return to &lcReturnToOnCancel
				endif empty(lcReturnToOnCancel)
		
		* This wasn't our error, so return the error resolution string.
		
			case lnPos > 0 and not (lcObject == upper(This.Name) or ;
				'DATAENVIRONMENT' $ upper(tcMethod))
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* If Cancel was chosen but the master program is this form, we'll just cancel.
		
			case lcReturn = ccMSG_CANCEL and empty(lcReturnToOnCancel)
				cancel
		
		* Cancel was chosen, so return to the master program.
		
			case lcReturn = ccMSG_CANCEL
				return to &lcReturnToOnCancel
		
		* Return to the routine in error to continue on.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE finderrorhandler		&& Find the first parent for a specified object that has code in its Error method
		*==============================================================================
		* Method:			FindErrorHandler
		* Status:			Public
		* Purpose:			Travel up the containership hierarchy until we find a
		*						parent for the specified object that has code in its
		*						Error method
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	12/04/98
		* Parameters:		toObject - an object reference to the desired object
		* Returns:			an object reference to the first parent of the specified
		*						object that has code in its Error method if one could
		*						be found, or .NULL. if not
		* Environment in:	none
		* Environment out:	none
		* Note:				this method prevents a problem with controls sitting on
		*						base class Page or Column objects -- no error trapping
		*						gets done if no custom code is directly entered into
		*						these objects
		*==============================================================================
		
		lparameters toObject
		local loParent
		loParent = toObject.Parent
		do while vartype(loParent) = 'O'
			do case
				case pemstatus(loParent, 'Error', 0)
					exit
				case type('loParent.Parent') = 'O'
					loParent = loParent.Parent
				otherwise
					loParent = .NULL.
			endcase
		enddo while vartype('loParent') = 'O'
		return loParent
		
	ENDPROC

	PROCEDURE GotFocus
		*==============================================================================
		* Method:			GotFocus
		* Status:			Public
		* Purpose:			Called when the window receives focus
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	03/05/99
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	This.RefreshForm() is called to ensure any BeforeRefresh
		*						and AfterRefresh behaviors are triggered
		*==============================================================================
		
		This.RefreshForm()
		
	ENDPROC

	PROCEDURE handleerror		&& Handles an error
		*==============================================================================
		* Method:			HandleError
		* Status:			Public
		* Purpose:			Handles an error
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	02/04/2000
		* Parameters:		none
		* Returns:			a string indicating the error resolution; see SFERRORS.H
		*						for the possible values
		* Environment in:	This.nLastError points to the row in This.aErrorInfo that
		*						has information about the current error
		* Environment out:	an error message may have been displayed, or some other
		*						error resolution may have been taken
		* Notes:			if This.oError contains an error handling object, its
		*						ErrorHandler method is called
		*					if a global oError contains an error handling object, its
		*						ErrorHandler method is called
		*					if an ON ERROR routine is in effect, it's called
		*					if none of these is true, a generic error message is
		*						displayed
		*==============================================================================
		
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcErrorMessage, ;
			lcErrorInfo, ;
			lcSource, ;
			loError, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		with This
			lnError        = .aErrorInfo[.nLastError, cnAERR_NUMBER]
			lcMethod       = .Name + '.' + .aErrorInfo[.nLastError, cnAERR_METHOD]
			lnLine         = .aErrorInfo[.nLastError, cnAERR_LINE]
			lcErrorMessage = .aErrorInfo[.nLastError, cnAERR_MESSAGE]
			lcErrorInfo    = .aErrorInfo[.nLastError, cnAERR_OBJECT]
			lcSource       = .aErrorInfo[.nLastError, cnAERR_SOURCE]
		
		* Get a reference to our error handling object if there is one. It could either
		* be a member of the form or a global object.
		
			do case
				case vartype(.oError) = 'O'
					loError = .oError
				case type('oError.Name') = 'C'
					loError = oError
				otherwise
					loError = .NULL.
			endcase
			do case
		
		* If the error is "cannot set focus during valid" or "DataEnvironment already
		* unloaded", we'll let it go.
		
				case lnError = cnERR_CANT_SET_FOCUS or lnError = cnERR_DE_UNLOADED
					lcReturn = ccMSG_CONTINUE
		
		* We have an error handling object, so call its ErrorHandler() method.
		
				case not isnull(loError)
					lcReturn = loError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
				case not empty(on('ERROR'))
					lcError = upper(on('ERROR'))
					lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
					lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
					lcError = strtran(lcError, ',ERROR()',  ',lnError')
					lcError = strtran(lcError, ' ERROR()',  ' lnError')
					lcError = strtran(lcError, 'LINENO()',  'lnLine')
					lcError = strtran(lcError, 'MESSAGE()', 'lcErrorMessage')
					lcError = strtran(lcError, 'SYS(2018)', 'lcErrorInfo')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
					if left(lcError, 3) = 'DO ' or '=' $ lcError
						&lcError
						lcReturn = ccMSG_CONTINUE
					else
						lcReturn = &lcError
					endif left(lcError, 3) = 'DO ' ...
		
		* We don't have an error handling object, so display a dialog box.
		
				otherwise
					lcMessage = ccMSG_ERROR_NUM + ' ' + ltrim(str(lnError)) + ccCR + ;
						ccMSG_MESSAGE + ' ' + lcErrorMessage + ccCR + ;
						iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
						ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
						ltrim(str(lnLine)) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose Yes to display the debugger, No to continue ' + ;
						'without the debugger, or Cancel to cancel execution', ;
						MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
					lcReturn = ccMSG_CONTINUE
					do case
						case lnChoice = IDYES
							lcReturn = ccMSG_DEBUG
						case lnChoice = IDCANCEL
							lcReturn = ccMSG_CANCEL
					endcase
			endcase
		endwith
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not upper(lcReturn) $ upper(ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ;
			ccMSG_CLOSEFORM + ccMSG_DEBUG), ccMSG_CONTINUE, lcReturn)
		return lcReturn
		
	ENDPROC

	PROCEDURE Init
		*==============================================================================
		* Method:			Init
		* Status:			Public
		* Purpose:			Initializes the object
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	06/06/2000
		* Parameters:		none
		* Returns:			.T. if everything succeeded, or .F. if an error occurred
		* Environment in:	MAKEOBJECT.PRG can be found
		* Environment out:	if This.Icon is empty, it's set to _screen.Icon
		*					This.BorderStyle is set to This.nBorderStyle
		*					This.oUtility may be set to an existing or may contain a
		*						new SFUtility object
		*					This.oMessage may be set to an existing or may contain a
		*						new SFMessage object
		*==============================================================================
		
		with This
		
		* If the Icon property is blank, grab the screen's or active form's.
		
			do case
				case not empty(.Icon)
				case _screen.Visible
					.Icon = _screen.Icon
				case .ShowWindow = 1 and type('_screen.ActiveForm.Name') = 'C'
					.Icon = _screen.ActiveForm.Icon
			endcase
		
		* Set the BorderStyle property as desired.
		
			.BorderStyle = .nBorderStyle
		
		* Get or create references to SFUtility and SFMessageMgr objects.
		
			do case
				case type('.oUtility.Name') = 'C'
				case type('oUtility.Name') = 'C'
					.oUtility = oUtility
				otherwise
					.oUtility = MakeObject('SFUtility', 'SFUtility.vcx')
			endcase
			do case
				case type('.oMessage.Name') = 'C'
				case type('oMessage.Name') = 'C'
					.oMessage = oMessage
				otherwise
					.oMessage = MakeObject('SFMessageMgr', 'SFMessage.vcx', '', ;
						.Caption)
			endcase
		endwith
		return not This.lErrorOccurred
		
	ENDPROC

	PROCEDURE Load
		*==============================================================================
		* Method:			Load
		* Status:			Public
		* Purpose:			Sets up environmental things before the form instantiates
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	06/04/2001
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the environment is set up the way we want
		*					the locations of tables in the DataEnvironment may have
		*						been changed
		*==============================================================================
		
		with This
		
		* Set some environmental things the way we want if we're in a private
		* datasession. These are in alphabetical order. Not all are datasession-
		* specific, but we'll set 'em anyway.
		
			if .DataSession = 2
				set ansi       off
				set bell       off			&& not datasession-specific
				set compatible off			&& not datasession-specific
				set cpdialog   off			&& not datasession-specific
				set deleted    on
				set exact      off
				set exclusive  off
				set fullpath   on			&& not datasession-specific
				set multilocks on
				set near       off
				set notify     off			&& not datasession-specific
				set nulldisplay to ''		&& not datasession-specific
				set safety     off
				set talk       off
				set unique     off
		
		* Set CENTURY after SYSFORMATS, since SYSFORMATS changes CENTURY.
		
				set sysformats on
				set century    on
			endif .DataSession = 2
		
		* If the tables haven't been opened yet, set the data directory for all
		* databases and free tables, then open the tables. If we don't have an
		* application object, just open the tables.
		
			do case
				case type('.DataEnvironment') <> 'O' or ;
					.DataEnvironment.AutoOpenTables
				case type('oApp.Name') = 'C' and pemstatus(oApp, 'SetDataDirectory', 5)
					oApp.SetDataDirectory(.DataEnvironment)
					.DataEnvironment.OpenTables()
				otherwise
					.DataEnvironment.OpenTables()
			endcase
		endwith
		
	ENDPROC

	PROCEDURE refreshform		&& Refreshes the form
		*==============================================================================
		* Method:			RefreshForm
		* Status:			Public
		* Purpose:			Refreshes the form
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	03/16/98
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the form has been refreshed and any code in the
		*						BeforeRefresh and AfterRefresh methods has executed
		*==============================================================================
		
		with This
			.LockScreen = .T.
			.BeforeRefresh()
			.Refresh()
			.AfterRefresh()
			.LockScreen = .F.
		endwith
		
	ENDPROC

	PROCEDURE Release
		* Release the object. Note the avoidance of "with This" in this code to prevent
		* potential problems with dangling object references.
		
		if This.lRelease
			nodefault
			return .F.
		endif This.lRelease
		This.Cleanup()
		
	ENDPROC

	PROCEDURE releasemembers		&& Abstract method to nuke member references
	ENDPROC

	PROCEDURE reseterror		&& Resets lErrorOccurred and aErrorInfo.
		*==============================================================================
		* Method:			ResetError
		* Status:			Public
		* Purpose:			Reset lErrorOccurred and aErrorInfo
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	03/16/98
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	This.lErrorOccurred is .F.
		*					This.nLastError is 1
		*					This.aErrorInfo is dimensioned to a single blank row
		*==============================================================================
		
		with This
			.lErrorOccurred = .F.
			dimension .aErrorInfo[1, cnAERR_MAX]
			.aErrorInfo = ''
			.nLastError = 1
		endwith
		
	ENDPROC

	PROCEDURE RightClick
		*==============================================================================
		* Method:			RightClick
		* Status:			Public
		* Purpose:			Display a right-click menu
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	03/16/98
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	a menu may have been displayed and action taken from the
		*						choice the user made
		*==============================================================================
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE seterror		&& Sets lErrorOccurred and aErrorInfo to information about the most recent error.
		*==============================================================================
		* Method:			SetError
		* Status:			Public
		* Purpose:			Handle errors
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	12/21/98
		* Parameters:		tcMethod - the method or function the error occurred in
		*					tnLine   - the line number within tcMethod
		*					taError  - an array of error information
		* Returns:			.T.
		* Environment in:	This.aErrorInfo is dimensioned appropriately
		*					This.lErrorSet is .T. if this method has already been called
		*						for this error
		* Environment out:	This.lErrorOccurred is .T.
		*					This.lErrorSet is .T.
		*					This.nLastError points to the current row in This.aErrorInfo
		*					This.aErrorInfo is filled with error information as
		*						follows:
		*
		*					Column	Information
		*					------	-----------
		*					1 - 7	same as AERROR()
		*					8		method error occurred in
		*					9		line error occurred on
		*					10		code causing error
		*					11		date/time error occurred
		*					12		not used
		*==============================================================================
		
		lparameters tcMethod, ;
			tnLine, ;
			taError
		local lnRows, ;
			lnCols, ;
			lnLast, ;
			lnError, ;
			lnRow, ;
			lnI
		external array taError
		with This
		
		* If we've already been called, just update the method information.
		
			if .lErrorInfoSaved
				.aErrorInfo[.nLastError, cnAERR_METHOD] = tcMethod
			else
		
		* Flag that an error occurred.
		
				.lErrorOccurred  = .T.
				.lErrorInfoSaved = .T.
				lnRows = alen(taError, 1)
				lnCols = alen(taError, 2)
				lnLast = iif(empty(.aErrorInfo[1, 1]), 0, alen(.aErrorInfo, 1))
				dimension .aErrorInfo[lnLast + lnRows, cnAERR_MAX]
		
		* For each row in the error array, put each column into our array.
		
				for lnError = 1 to lnRows
					lnRow = lnLast + lnError
					for lnI = 1 to lnCols
						.aErrorInfo[lnRow, lnI] = taError[lnError, lnI]
					next lnI
		
		* Add some additional information to the current row in our array.
		
					.aErrorInfo[lnRow, cnAERR_METHOD]   = tcMethod
					.aErrorInfo[lnRow, cnAERR_LINE]     = tnLine
					.aErrorInfo[lnRow, cnAERR_SOURCE]   = ;
						iif(message(1) = .aErrorInfo[lnRow, cnAERR_MESSAGE], '', ;
						message(1))
					.aErrorInfo[lnRow, cnAERR_DATETIME] = datetime()
				next lnError
				.nLastError = alen(.aErrorInfo, 1)
			endif not .lErrorInfoSaved
		endwith
		
	ENDPROC

	PROCEDURE setfocustofirstobject		&& Sets focus to the first object in the specified container
		*==============================================================================
		* Method:			SetFocusToFirstObject
		* Status:			Public
		* Purpose:			Sets focus to the first object in the specified container
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	06/01/99
		* Parameters:		toContainer - the container to check
		* Returns:			.T. if it set focus to an object
		* Environment in:	none
		* Environment out:	if this method returns .T., focus has been set to an object
		*==============================================================================
		
		lparameters toContainer
		local loContainer, ;
			laObjects[1], ;
			lnObjects, ;
			lnIndex, ;
			loControl, ;
			llReturn, ;
			lnI, ;
			loObject, ;
			lcClass, ;
			lnPage, ;
			loPage
		
		* If the container wasn't specified, let's use the form.
		
		loContainer = iif(vartype(toContainer) = 'O', toContainer, This)
		
		* Get an array of all member objects of the specified container. Initialize
		* some variables.
		
		lnObjects = amembers(laObjects, loContainer, 2)
		lnIndex   = 99999
		loControl = .NULL.
		llReturn  = .F.
		
		* Check each of the member objects until we come across the one lowest in the
		* tab order.
		
		for lnI = 1 to lnObjects
			loObject = evaluate('loContainer.' + laObjects[lnI])
			lcClass  = upper(loObject.BaseClass)
			do case
		
		* If the object doesn't have a TabIndex property, is a label, is disabled, or
		* isn't visible, ignore it.
		
				case type('loObject.TabIndex') = 'U' or lcClass = 'LABEL' or ;
					(type('loObject.TabStop') = 'L' and not loObject.TabStop and ;
						upper(loObject.BaseClass) <> 'PAGEFRAME') or ;
					(type('loObject.Enabled') = 'L' and not loObject.Enabled) or ;
					(type('loObject.Visible') = 'L' and not loObject.Visible)
		
		* If this object is lower in tab order than any we've already seen, grab a
		* reference to it.
		
				case loObject.TabIndex < lnIndex
					loControl = loObject
					lnIndex   = loObject.TabIndex
			endcase
		next lnI
		
		* If we found an object, set focus to it. We may need to drill down into it if
		* it's a container.
		
		if vartype(loControl) = 'O'
			lcClass = upper(loControl.BaseClass)
			do case
		
		* If this is a pageframe, choose the first page, then call ourselves
		* recursively to find the first object inside it and set focus to it.
		
				case lcClass = 'PAGEFRAME'
					lnIndex = 99999
					lnPage  = 0
					for lnI = 1 to loControl.PageCount
						loPage = loControl.Pages[lnI]
						if loPage.PageOrder < lnIndex
							lnPage  = lnI
							lnIndex = loPage.PageOrder
						endif loPage.PageOrder < lnIndex
					next loPage
					if lnPage > 0
						if loControl.ActivePage <> lnPage
							loControl.ActivePage = lnPage
						endif loControl.ActivePage <> lnPage
						llReturn = This.SetFocusToFirstObject(loControl.Pages[lnPage])
					endif lnPage > 0
		
		* If this is another type of container, call ourselves recursively to find the
		* first object inside it and set focus to it.
		
				case lcClass $ 'COMMANDGROUP,OPTIONGROUP,CONTAINER'
					llReturn = This.SetFocusToFirstObject(loControl)
		
		* Set focus to the object.
		
				otherwise
					loControl.SetFocus()
					llReturn = .T.
		endcase
		endif vartype(loControl) = 'O' ...
		return llReturn
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object (abstract in this
		*						class)
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	12/11/98
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items may have been added to the menu in a
		*						subclass of this class
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE Show
		*==============================================================================
		* Method:			Show
		* Status:			Public
		* Purpose:			Display the form
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	12/04/98
		* Parameters:		tnStyle - the style for the window
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	focus is set to the first object in the form
		*==============================================================================
		
		lparameters tnStyle
		local lcType
		lcType = vartype(tnStyle)
		if pcount() = 0 or lcType = 'L' or (lcType = 'N' and tnStyle = This.WindowType)
			This.SetFocusToFirstObject(This)
		endif pcount() = 0 ...
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	02/10/2000
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	MAKEOBJECT.PRG and SFMENU.VCX can be found (and VARTYPE.PRG
		*						in VFP 5)
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		private loObject, ;
			loHook
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
		
		* Define the menu if it hasn't already been defined.
		
			if vartype(.oMenu) <> 'O'
				.oMenu = MakeObject('SFShortcutMenu', 'SFMENU.VCX')
			endif vartype(.oMenu) <> 'O'
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfgrid AS grid 		&& The base class for Grid objects
 	*< CLASSDATA: Baseclass="grid" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class.
		*m: enabled_assign
		*m: getcaption		&& Gets the caption for the specified field
		*m: release		&& Releases the object.
		*m: setupcolumns		&& Sets up things we need about columns, including the DynamicBackColor so the selected row is highlighted
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class.
		*p: builderx		&& Holds the name of the preferred custom builder
		*p: cselectedbackcolor		&& The forecolor to use for selected rows
		*p: cselectedforecolor		&& The forecolor to use for selected rows
		*p: lautosetup		&& .T. to automatically call SetupColumns() from Init
		*p: lgridhasfocus		&& .T. if the grid has focus
		*p: lhighlightentirerow		&& .T. to highlight an entire row
		*p: ljustgotfocus		&& .T. if the grid just got focus; set to .T. in When and .F. in AfterRowColChange (since AfterRowColChange fires when the grid receives focus, even if the row not changed, this can be useful)
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: nbackcolor		&& The saved BackColor when SetEnabled is called with .F.
		*p: nrecno		&& The record number of the highlighted row
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to an SFShortcutMenu object
	*</DefinedPropArrayMethod>

	PROTECTED lgridhasfocus,ljustgotfocus,nbackcolor
	AllowHeaderSizing = .F.
	AllowRowSizing = .F.
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class.
	builderx = ( home() + 'wizards\builderd, builderdform')		&& Holds the name of the preferred custom builder
	cselectedbackcolor = 0,255,255		&& The forecolor to use for selected rows
	cselectedforecolor = 0,0,0		&& The forecolor to use for selected rows
	lautosetup = .T.		&& .T. to automatically call SetupColumns() from Init
	lgridhasfocus = .F.		&& .T. if the grid has focus
	lhighlightentirerow = .T.		&& .T. to highlight an entire row
	ljustgotfocus = .F.		&& .T. if the grid just got focus; set to .T. in When and .F. in AfterRowColChange (since AfterRowColChange fires when the grid receives focus, even if the row not changed, this can be useful)
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Name = "sfgrid"
	nbackcolor = 0		&& The saved BackColor when SetEnabled is called with .F.
	nrecno = 0		&& The record number of the highlighted row
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to an SFShortcutMenu object
	SplitBar = .F.
	
	PROCEDURE about		&& Provides documentation for the class.
		*==============================================================================
		* Class:					SFGrid
		* Based On:					Grid
		* Purpose:					Base class for all Grid objects
		* Author:					Doug Hennig
		* Copyright:				(c) 1996 Stonefield Systems Group Inc.
		* Last revision:			03/04/2000
		* Include file:				SFCTRLS.H
		*
		* Changes in "Based On" class properties:
		*	AllowHeaderSizing:		.F.
		*	AllowRowSizing:			.F.
		*	SplitBar:				.F.
		*
		* Changes in "Based On" class methods:
		*	AfterRowColChange:		code to support row highlighting
		*	BeforeRowColChange:		lock the form so row highlighting works
		*	Destroy:				nukes member objects
		*	Error:					calls the parent Error method so error handling
		*							goes up the containership hierarchy
		*	Init:					call This.SetupColumns()
		*	Refresh:				refresh contained controls
		*	RightClick:				call This.ShowMenu()
		*	Valid:					set This.lGridHasFocus to .F.
		*	When:					set This.lGridHasFocus and This.lJustGotFocus to
		*							.T.
		*
		* Custom public properties added:
		*	Builder:				holds the name of a custom builder (SFGridBuilder)
		*	BuilderX:				holds the name of the preferred custom builder
		*	cSelectedBackColor:		the backcolor to use for selected rows (default 0,
		*							255,255)
		*	cSelectedForeColor:		the forecolor to use for selected rows (default 0,
		*							0,0)
		*	lAutoSetup:				.T. to automatically call SetupColumns() from Init
		*	lHighlightEntireRow:	.T. to highlight an entire row
		*	lUseFormShortcutMenu:	.T. if the form's shortcut menu items should be
		*							included with this object's
		*	nRecno:					the record number of the highlighted row
		*	oHook:					a reference to a hooked object (default = .NULL.)
		*	oMenu:					a reference to an SFShortcutMenu object (default =
		*							.NULL.)
		*
		* Custom protected properties added:
		*	lGridHasFocus:			.T. if the grid has focus
		*	lJustGotFocus:			.T. if the grid just got focus; set to .T. in When
		*							and .F. in AfterRowColChange (since
		*							AfterRowColChange fires when the grid receives
		*							focus, even if the row not changed, this can be
		*							useful)
		*	nBackColor:				the saved BackColor when SetEnabled is called with
		*							.F.
		*
		* Custom public methods added:
		*	About:					provides documentation for the class
		*	GetCaption:				gets the caption for the specified field
		*	Release:				releases the object
		*	SetEnabled:				sets the Enabled property of the object to the
		*							specified value and the BackColor to the
		*							container's BackColor so all object appear to be
		*							enabled or disabled
		*	SetupColumns:			sets up things we need about columns, including the
		*							DynamicBackColor so the selected row is highlighted
		*	ShortcutMenu:			populates the shortcut menu
		*	ShowMenu:				display a shortcut menu
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE AfterRowColChange
		* If we're supposed to highlight the entire row, save the current record
		* number, refresh the grid, and unlock the screen so we see the changes.
		
		lparameters tnColIndex
		with This
			if .lHighlightEntireRow
				.nRecno = recno(.RecordSource)
				if not .lGridHasFocus
					.Refresh()
				endif not .lGridHasFocus
				Thisform.LockScreen = .F.
			endif .lHighlightEntireRow
		
		* Flag that the grid didn't just receive focus.
		
			.lJustGotFocus = .F.
		endwith
		
	ENDPROC

	PROCEDURE BeforeRowColChange
		* If we're supposed to highlight the entire row, lock the screen so we don't
		* see anything until after we're done (AfterRowColChange).
		
		lparameters tnColIndex
		if This.lHighlightEntireRow
			Thisform.LockScreen = This.lGridHasFocus
		endif This.lHighlightEntireRow
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		This.oMenu = .NULL.
		
	ENDPROC

	PROCEDURE enabled_assign
		* Enable or disabled member objects.
		
		lparameters tlEnabled
		with This
			.Enabled = tlEnabled
			if tlEnabled
				.BackColor = iif(.nBackColor = 0, .BackColor, .nBackColor)
			else
				.nBackColor = .BackColor
				.BackColor  = .Parent.BackColor
			endif tlEnabled
		endwith
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	03/04/2000
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local laError[1], ;
			lcName, ;
			lcMethod, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcSource, ;
			lcMessage, ;
			lnChoice
		
		* Get information about the error.
		
		aerror(laError)
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, tnLine, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(tnError, lcMethod, tnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, tnLine, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(tnError, lcMethod, tnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',tnError')
				lcError = strtran(lcError, ' ERROR()',  ' tnError')
				lcError = strtran(lcError, 'LINENO()',  'tnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + ltrim(str(tnError)) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(tnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					ltrim(str(tnLine)) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
					'Choose Yes to display the debugger, No to continue ' + ;
					'without the debugger, or Cancel to cancel execution', ;
					MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE getcaption		&& Gets the caption for the specified field
		*==============================================================================
		* Method:			GetCaption
		* Status:			Public
		* Purpose:			Get the caption for the specified field
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	12/04/98
		* Parameters:		tcField - the field to get the caption for
		* Returns:			the caption for the field
		* Environment in:	if the field's table is in a DBC, that DBC is the current
		*						one
		*					oMeta may contain an object reference to DBCXMgr
		* Environment out:	none
		*==============================================================================
		
		lparameters tcField
		local lcField, ;
			lcCaption
		lcField = substr(tcField, at('.', tcField) + 1)
		do case
			case not empty(dbc()) and indbc(tcField, 'Field')
				lcCaption = dbgetprop(tcField, 'Field', 'Caption')
			case vartype('oMeta') = 'O'
				lcCaption = nvl(oMeta.DBCXGetProp(tcField, 'Field', 'Caption'), '')
			otherwise
				lcCaption = ''
		endcase
		lcCaption = iif(empty(lcCaption), proper(strtran(lcField, '_', ' ')), ;
			lcCaption)
		return lcCaption
		
	ENDPROC

	PROCEDURE Init
		* Call the SetupColumns method so we can handle highlighting the entire row if
		* necessary.
		
		with This
			if .lAutoSetup
				.SetupColumns()
			endif .lAutoSetup
		endwith
		
	ENDPROC

	PROCEDURE Refresh
		* Ensure all contained controls are refreshed.
		
		local loColumn, ;
			loControl
		with This
			for each loColumn in .Columns
				for each loControl in loColumn.Controls
					if pemstatus(loControl, 'Refresh', 5)
						loControl.Refresh()
					endif pemstatus(loControl, 'Refresh', 5)
				next loControl
			next loColumn
		endwith
		
	ENDPROC

	PROCEDURE release		&& Releases the object.
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE setupcolumns		&& Sets up things we need about columns, including the DynamicBackColor so the selected row is highlighted
		*==============================================================================
		* Method:			SetupColumns
		* Status:			Public
		* Purpose:			Sets up the columns
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	12/07/98
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	This.lHighlightRow is .T. if we're supposed to highlight
		*						an entire row
		*					This.cSelectedBackColor is set to the backcolor to
		*						highlight the row with
		*					This.cSelectedForeColor is set to the forecolor to
		*						highlight the row with
		* Environment out:	This.nBackColor is set to This.BackColor
		*					if This.lHighlightEntireRow is .T., the DynamicBackColor
		*						and DynamicForeColor property of each column is set
		*						appropriately and This.nRecno is set to the current
		*						record # of the table
		*					if the table belongs to a database, that database is the
		*						current one
		*					headers with a default caption are changed to the caption
		*						for the field their column displays
		*==============================================================================
		
		local lcDatabase, ;
			loColumn, ;
			lcCaption
		with This
		
		* Save the current BackColor to nBackColor (we'll use nBackColor in the
		* SetEnabled method), set the DynamicBackColor of all columns so the selected
		* row is highlighted, and start nRecno at the current record number.
		
			.nBackColor = .BackColor
			if .ReadOnly
				.SetAll('ReadOnly', .T.)
			endif .ReadOnly
			if .lHighlightEntireRow
				.SetAll('DynamicBackColor', ;
					'iif(recno(This.RecordSource) = This.nRecno, rgb(' + ;
					.cSelectedBackColor + '), ' + ltrim(str(.BackColor)) + ')', ;
					'Column')
				.SetAll('DynamicForeColor', ;
					'iif(recno(This.RecordSource) = This.nRecno, rgb(' + ;
					.cSelectedForeColor + '), ' + ltrim(str(.ForeColor)) + ')', ;
					'Column')
				.nRecno = iif(used(.RecordSource), recno(.RecordSource), 1)
			endif .lHighlightEntireRow
		
		* Ensure the database for the RecordSource (if there is one) is selected.
		
			lcDatabase = cursorgetprop('DATABASE', .RecordSource)
			if not set('DATABASE') == lcDatabase and not empty(lcDatabase)
				set database to (lcDatabase)
			endif not set('DATABASE') == lcDatabase ...
		
		* Ensure each column has a valid header caption.
		
			for each loColumn in .Columns
				for each loObject in loColumn.Controls
					if upper(loObject.BaseClass) = 'HEADER'
						if loObject.Caption = 'Header1'
							lcCaption = .GetCaption(loColumn.ControlSource)
							loObject.Caption = lcCaption
						endif loObject.Caption = 'Header1'
						exit
					endif upper(loObject.BaseClass) = 'HEADER'
				next loObject
			next loColumn
		endwith
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	12/11/98
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	02/10/2000
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	MAKEOBJECT.PRG and SFMENU.VCX can be found (and VARTYPE.PRG
		*						in VFP 5)
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			if vartype(.oMenu) <> 'O'
				.oMenu = MakeObject('SFShortcutMenu', 'SFMENU.VCX')
			endif vartype(.oMenu) <> 'O'
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

	PROCEDURE Valid
		This.lGridHasFocus = .F.
		
	ENDPROC

	PROCEDURE When
		This.lGridHasFocus = .T.
		This.lJustGotFocus = .T.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfgridtextbox AS sftextbox OF "sfctrls.vcx" 		&& The base class for TextBox objects in grid columns
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	BorderStyle = 0
	Margin = 0
	Name = "sfgridtextbox"
	
	PROCEDURE about		&& Provides documentation for the class.
		*==============================================================================
		* Class:					SFGridTextBox
		* Based On:					SFTextBox (SFCtrls.vcx)
		* Purpose:					The base class for TextBox objects in grid columns
		* Author:					Doug Hennig
		* Copyright:				(c) 1996 Stonefield Systems Group Inc.
		* Last revision:			12/07/98
		* Include file:				none
		*
		* Changes in "Based On" class properties:
		*	BorderStyle:			0
		*	Height:					15
		*	Margin:					0
		*
		* Changes in "Based On" class methods:
		*	None
		*
		* Custom public properties added:
		*	None
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	None
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfimage AS image 		&& The base class for Image objects
 	*< CLASSDATA: Baseclass="image" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class.
		*m: release		&& Releases the object.
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class.
		*p: builderx		&& Holds the name of the preferred custom builder
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to an SFShortcutMenu object
	*</DefinedPropArrayMethod>

	BackStyle = 0
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class.
	builderx = ( home() + 'wizards\builderd, builderdform')		&& Holds the name of the preferred custom builder
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Name = "sfimage"
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to an SFShortcutMenu object
	
	PROCEDURE about		&& Provides documentation for the class.
		*==============================================================================
		* Class:					SFImage
		* Based On:					Image
		* Purpose:					Base class for all Image objects
		* Author:					Doug Hennig
		* Copyright:				(c) 1996 Stonefield Systems Group Inc.
		* Last revision:			03/04/2000
		* Include file:				SFCTRLS.H
		*
		* Changes in "Based On" class properties:
		*	BackStyle:				0 (Transparent)
		*
		* Changes in "Based On" class methods:
		*	Destroy:				nukes member objects
		*	Error:					calls the parent Error method so error handling
		*							goes up the containership hierarchy
		*	RightClick:				call This.ShowMenu()
		*
		* Custom public properties added:
		*	Builder:				holds the name of a custom builder
		*	BuilderX:				holds the name of the preferred custom builder
		*	lUseFormShortcutMenu:	.T. if the form's shortcut menu items should be
		*							included with this object's
		*	oHook:					a reference to a hooked object (default = .NULL.)
		*	oMenu:					a reference to an SFShortcutMenu object (default =
		*							.NULL.)
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	About:					provides documentation for the class
		*	Release:				releases the object
		*	ShortcutMenu:			populates the shortcut menu
		*	ShowMenu:				display a shortcut menu
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	03/04/2000
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local laError[1], ;
			lcName, ;
			lcMethod, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcSource, ;
			lcMessage, ;
			lnChoice
		
		* Get information about the error.
		
		aerror(laError)
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, tnLine, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(tnError, lcMethod, tnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, tnLine, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(tnError, lcMethod, tnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',tnError')
				lcError = strtran(lcError, ' ERROR()',  ' tnError')
				lcError = strtran(lcError, 'LINENO()',  'tnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + ltrim(str(tnError)) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(tnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					ltrim(str(tnLine)) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
					'Choose Yes to display the debugger, No to continue ' + ;
					'without the debugger, or Cancel to cancel execution', ;
					MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE release		&& Releases the object.
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	12/11/98
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	02/10/2000
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	MAKEOBJECT.PRG and SFMENU.VCX can be found (and VARTYPE.PRG
		*						in VFP 5)
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			if vartype(.oMenu) <> 'O'
				.oMenu = MakeObject('SFShortcutMenu', 'SFMENU.VCX')
			endif vartype(.oMenu) <> 'O'
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sflabel AS label 		&& The base class for Label objects
 	*< CLASSDATA: Baseclass="label" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class.
		*m: release		&& Releases the object.
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class.
		*p: builderx		&& Holds the name of the preferred custom builder
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to an SFShortcutMenu object
	*</DefinedPropArrayMethod>

	AutoSize = .T.
	BackStyle = 0
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class.
	builderx = ( home() + 'wizards\builderd, builderdform')		&& Holds the name of the preferred custom builder
	Caption = "Label1"
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Name = "sflabel"
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to an SFShortcutMenu object
	
	PROCEDURE about		&& Provides documentation for the class.
		*==============================================================================
		* Class:					SFLabel
		* Based On:					Label
		* Purpose:					Base class for all Label objects
		* Author:					Doug Hennig
		* Copyright:				(c) 1996 Stonefield Systems Group Inc.
		* Last revision:			03/04/2000
		* Include file:				SFCTRLS.H
		*
		* Changes in "Based On" class properties:
		*	AutoSize:				.T.
		*	BackStyle:				0 (Transparent)
		*
		* Changes in "Based On" class methods:
		*	Destroy:				nukes member objects
		*	Error:					calls the parent Error method so error handling
		*							goes up the containership hierarchy
		*	RightClick:				call This.ShowMenu()
		*
		* Custom public properties added:
		*	Builder:				holds the name of a custom builder
		*	BuilderX:				holds the name of the preferred custom builder
		*	lUseFormShortcutMenu:	.T. if the form's shortcut menu items should be
		*							included with this object's
		*	oHook:					a reference to a hooked object (default = .NULL.)
		*	oMenu:					a reference to an SFShortcutMenu object (default =
		*							.NULL.)
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	About:					provides documentation for the class
		*	Release:				releases the object
		*	ShortcutMenu:			populates the shortcut menu
		*	ShowMenu:				display a shortcut menu
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		This.oMenu = .NULL.
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	03/04/2000
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local laError[1], ;
			lcName, ;
			lcMethod, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcSource, ;
			lcMessage, ;
			lnChoice
		
		* Get information about the error.
		
		aerror(laError)
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, tnLine, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(tnError, lcMethod, tnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, tnLine, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(tnError, lcMethod, tnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',tnError')
				lcError = strtran(lcError, ' ERROR()',  ' tnError')
				lcError = strtran(lcError, 'LINENO()',  'tnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + ltrim(str(tnError)) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(tnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					ltrim(str(tnLine)) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
					'Choose Yes to display the debugger, No to continue ' + ;
					'without the debugger, or Cancel to cancel execution', ;
					MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE release		&& Releases the object.
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	12/11/98
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	02/10/2000
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	MAKEOBJECT.PRG and SFMENU.VCX can be found (and VARTYPE.PRG
		*						in VFP 5)
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			if vartype(.oMenu) <> 'O'
				.oMenu = MakeObject('SFShortcutMenu', 'SFMENU.VCX')
			endif vartype(.oMenu) <> 'O'
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfline AS line 		&& The base class for Line objects
 	*< CLASSDATA: Baseclass="line" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class.
		*m: release		&& Releases the object.
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class.
		*p: builderx		&& Holds the name of the preferred custom builder
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to an SFShortcutMenu object
	*</DefinedPropArrayMethod>

	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class.
	builderx = ( home() + 'wizards\builderd, builderdform')		&& Holds the name of the preferred custom builder
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Name = "sfline"
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to an SFShortcutMenu object
	
	PROCEDURE about		&& Provides documentation for the class.
		*==============================================================================
		* Class:					SFLine
		* Based On:					Line
		* Purpose:					Base class for all Line objects
		* Author:					Doug Hennig
		* Copyright:				(c) 1996 Stonefield Systems Group Inc.
		* Last revision:			03/04/2000
		* Include file:				SFCTRLS.H
		*
		* Changes in "Based On" class properties:
		*	None
		*
		* Changes in "Based On" class methods:
		*	Destroy:				nukes member objects
		*	Error:					calls the parent Error method so error handling
		*							goes up the containership hierarchy
		*	RightClick:				call This.ShowMenu()
		*
		* Custom public properties added:
		*	Builder:				holds the name of a custom builder
		*	BuilderX:				holds the name of the preferred custom builder
		*	lUseFormShortcutMenu:	.T. if the form's shortcut menu items should be
		*							included with this object's
		*	oHook:					a reference to a hooked object (default = .NULL.)
		*	oMenu:					a reference to an SFShortcutMenu object (default =
		*							.NULL.)
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	About:					provides documentation for the class
		*	Release:				releases the object
		*	ShortcutMenu:			populates the shortcut menu
		*	ShowMenu:				display a shortcut menu
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		This.oMenu = .NULL.
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	03/04/2000
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local laError[1], ;
			lcName, ;
			lcMethod, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcSource, ;
			lcMessage, ;
			lnChoice
		
		* Get information about the error.
		
		aerror(laError)
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, tnLine, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(tnError, lcMethod, tnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, tnLine, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(tnError, lcMethod, tnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',tnError')
				lcError = strtran(lcError, ' ERROR()',  ' tnError')
				lcError = strtran(lcError, 'LINENO()',  'tnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + ltrim(str(tnError)) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(tnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					ltrim(str(tnLine)) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
					'Choose Yes to display the debugger, No to continue ' + ;
					'without the debugger, or Cancel to cancel execution', ;
					MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE release		&& Releases the object.
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	12/11/98
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	02/10/2000
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	MAKEOBJECT.PRG and SFMENU.VCX can be found (and VARTYPE.PRG
		*						in VFP 5)
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			if vartype(.oMenu) <> 'O'
				.oMenu = MakeObject('SFShortcutMenu', 'SFMENU.VCX')
			endif vartype(.oMenu) <> 'O'
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sflistbox AS listbox 		&& The base class for ListBox objects
 	*< CLASSDATA: Baseclass="listbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class.
		*m: anychange		&& Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place.
		*m: release		&& Releases the object.
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class.
		*p: builderx		&& Holds the name of the preferred custom builder
		*p: lrequeryoninit		&& .T. to call Requery() from Init()
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to an SFShortcutMenu object
		*a: aitems[1,0]		&& An array that can hold the values used for the ListBox when RowSourceType is 5.
	*</DefinedPropArrayMethod>

	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class.
	builderx = ( home() + 'wizards\builderd, builderdform')		&& Holds the name of the preferred custom builder
	IntegralHeight = .T.
	ItemTips = .T.
	lrequeryoninit = .T.		&& .T. to call Requery() from Init()
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Name = "sflistbox"
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to an SFShortcutMenu object
	RowSource = "This.aItems"
	RowSourceType = 5
	
	PROCEDURE about		&& Provides documentation for the class.
		*==============================================================================
		* Class:					SFListBox
		* Based On:					ListBox
		* Purpose:					Base class for all ListBox objects
		* Author:					Doug Hennig
		* Copyright:				(c) 1996-2001 Stonefield Systems Group Inc.
		* Last revision:			10/11/2001
		* Include file:				SFCTRLS.H
		*
		* Changes in "Based On" class properties:
		*	IntegralHeight:			.T.
		*	ItemTips:				.T.
		*	RowSource:				This.aItems (see below)
		*	RowSourceType:			5 (Array)
		*
		* Changes in "Based On" class methods:
		*	Destroy:				nukes member objects
		*	Error:					calls the parent Error method so error handling
		*							goes up the containership hierarchy
		*	Init:					initialize This.aItems to blanks and call
		*							This.Requery() if This.lRequeryOnInit is .T.
		*	InteractiveChange:		call This.AnyChange()
		*	ProgrammaticChange:		call This.AnyChange()
		*	Requery:				handle RowSourceType = 1-Value when This.aItems
		*							contains the array of values
		*	RightClick:				call This.ShowMenu()
		*
		* Custom public properties added:
		*	aItems[1]:				an array that can hold the values used for the
		*							ListBox when RowSourceType is 5
		*	Builder:				holds the name of a custom builder
		*	BuilderX:				holds the name of the preferred custom builder
		*	lRequeryOnInit:			.T. to call Requery() from Init()
		*	lUseFormShortcutMenu:	.T. if the form's shortcut menu items should be
		*							included with this object's
		*	oHook:					a reference to a hooked object (default = .NULL.)
		*	oMenu:					a reference to an SFShortcutMenu object (default =
		*							.NULL.)
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	About:					provides documentation for the class
		*	AnyChange:				called by InteractiveChange() and
		*							ProgrammaticChange()
		*	Release:				releases the object
		*	ShortcutMenu:			populates the shortcut menu
		*	ShowMenu:				display a shortcut menu
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE anychange		&& Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place.
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		This.oMenu = .NULL.
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	03/04/2000
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local laError[1], ;
			lcName, ;
			lcMethod, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcSource, ;
			lcMessage, ;
			lnChoice
		
		* Get information about the error.
		
		aerror(laError)
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, tnLine, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(tnError, lcMethod, tnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, tnLine, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(tnError, lcMethod, tnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',tnError')
				lcError = strtran(lcError, ' ERROR()',  ' tnError')
				lcError = strtran(lcError, 'LINENO()',  'tnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + ltrim(str(tnError)) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(tnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					ltrim(str(tnLine)) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
					'Choose Yes to display the debugger, No to continue ' + ;
					'without the debugger, or Cancel to cancel execution', ;
					MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE Init
		with This
		
		* Call Requery() if we're supposed to; otherwise, initialize aItems to a blank
		* string.
		
			if .lRequeryOnInit
				.Requery()
			else
				.aItems = ''
			endif .lRequeryOnInit
		endwith
		
	ENDPROC

	PROCEDURE InteractiveChange
		* Call a common method for handling changes.
		
		This.AnyChange()
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		* Call a common method for handling changes.
		
		This.AnyChange()
		
	ENDPROC

	PROCEDURE release		&& Releases the object.
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE Requery
		* If RowSource is 1-Value but aItems contains values, set RowSource to a comma-
		* delimited list of values from aItems. This allows disabled lines using a
		* prompt of "\-".
		
		lparameters tlNoAction
		local lnI
		with This
			if not tlNoAction and .RowSourceType = 1 and ;
				vartype(.aItems[1]) = 'C' and (not empty(.aItems[1]) or ;
				alen(.aItems, 1) > 0)
				.RowSource = ''
				for lnI = 1 to alen(.aItems, 1)
					.RowSource = .RowSource + iif(lnI = 1, '', ',') + .aItems[lnI, 1]
				next lnI
			endif not tlNoAction ...
		endwith
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	12/11/98
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	02/10/2000
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	MAKEOBJECT.PRG and SFMENU.VCX can be found (and VARTYPE.PRG
		*						in VFP 5)
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			if vartype(.oMenu) <> 'O'
				.oMenu = MakeObject('SFShortcutMenu', 'SFMENU.VCX')
			endif vartype(.oMenu) <> 'O'
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfmodaldialog AS sfform OF "sfctrls.vcx" 		&& The base class for modal dialogs
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	DoCreate = .T.
	MaxButton = .F.
	MinButton = .F.
	Name = "sfmodaldialog"
	WindowType = 1
	
	PROCEDURE about		&& Provides documentation for the class.
		*==============================================================================
		* Class:					SFModalDialog
		* Based On:					SFForm
		* Purpose:					The base class for modal dialogs
		* Author:					Doug Hennig
		* Copyright:				(c) 1996 Stonefield Systems Group Inc.
		* Last revision:			12/04/98
		* Include file:				none
		*
		* Changes in "Based On" class properties:
		*	MaxButton:				.F.
		*	MinButton:				.F.
		*	WindowType:				1 (Modal)
		*
		* Changes in "Based On" class methods:
		*	None
		*
		* Custom public properties added:
		*	None
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	None
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfmodaldialognotitle AS sfmodaldialog OF "sfctrls.vcx" 		&& A modal dialog with no border and title
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	DoCreate = .T.
	Name = "sfmodaldialognotitle"
	TitleBar = 0
	
	PROCEDURE about		&& Provides documentation for the class.
		*==============================================================================
		* Class:					SFModalDialogNoTitle
		* Based On:					SFModalDialog
		* Purpose:					Modal dialog with no title bar
		* Author:					Doug Hennig
		* Copyright:				(c) 1996 Stonefield Systems Group Inc.
		* Last revision:			12/04/98
		* Include file:				none
		*
		* Changes in "Based On" class properties:
		*	TitleBar:				0 - off
		*
		* Changes in "Based On" class methods:
		*	None
		*
		* Custom public properties added:
		*	None
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	None
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfoleboundcontrol AS oleboundcontrol 		&& The base class for OLEBoundControl objects
 	*< CLASSDATA: Baseclass="oleboundcontrol" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class.
		*m: release		&& Releases the object.
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class.
		*p: builderx		&& Holds the name of the preferred custom builder
		*p: ohook		&& A reference to a hooked object
	*</DefinedPropArrayMethod>

	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class.
	builderx = ( home() + 'wizards\builderd, builderdform')		&& Holds the name of the preferred custom builder
	Name = "sfoleboundcontrol"
	ohook = .NULL.		&& A reference to a hooked object
	
	PROCEDURE about		&& Provides documentation for the class.
		*==============================================================================
		* Class:					SFOLEBoundControl
		* Based On:					OLEBoundControl
		* Purpose:					The base class for all OLEBoundControl objects
		* Author:					Doug Hennig
		* Copyright:				(c) 1996 Stonefield Systems Group Inc.
		* Last revision:			03/04/2000
		* Include file:				SFCTRLS.H
		*
		* Changes in "Based On" class properties:
		*	None
		*
		* Changes in "Based On" class methods:
		*	Destroy:				nukes member objects
		*	Error:					calls the parent Error method so error handling
		*							goes up the containership hierarchy
		*
		* Custom public properties added:
		*	Builder:				holds the name of a custom builder
		*	BuilderX:				holds the name of the preferred custom builder
		*	oHook:					a reference to a hooked object (default = .NULL.)
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	About:					provides documentation for the class
		*	Release:				releases the object
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	03/04/2000
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local laError[1], ;
			lcName, ;
			lcMethod, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcSource, ;
			lcMessage, ;
			lnChoice
		
		* Get information about the error.
		
		aerror(laError)
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, tnLine, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(tnError, lcMethod, tnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, tnLine, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(tnError, lcMethod, tnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',tnError')
				lcError = strtran(lcError, ' ERROR()',  ' tnError')
				lcError = strtran(lcError, 'LINENO()',  'tnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + ltrim(str(tnError)) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(tnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					ltrim(str(tnLine)) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
					'Choose Yes to display the debugger, No to continue ' + ;
					'without the debugger, or Cancel to cancel execution', ;
					MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE release		&& Releases the object.
		* Release the object.
		
		release This
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfoptiongroup AS optiongroup 		&& The base class for OptionGroup objects
 	*< CLASSDATA: Baseclass="optiongroup" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class.
		*m: anychange		&& Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place.
		*m: enabled_assign
		*m: release		&& Releases the object.
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*m: validation		&& Abstract method for custom validation code
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class.
		*p: builderx		&& Holds the name of the preferred custom builder
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to an SFShortcutMenu object
	*</DefinedPropArrayMethod>

	BackStyle = 0
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class.
	builderx = ( home() + 'wizards\builderd, builderdform')		&& Holds the name of the preferred custom builder
	ButtonCount = 2
	Height = 46
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Name = "sfoptiongroup"
	ohook = .NULL.		&& A reference to a hooked object
	Width = 71
	Option1.Caption = "Option1"
	Option1.Height = 17
	Option1.Left = 5
	Option1.Name = "Option1"
	Option1.Top = 5
	Option1.Width = 61
	Option2.Caption = "Option2"
	Option2.Height = 17
	Option2.Left = 5
	Option2.Name = "Option2"
	Option2.Top = 24
	Option2.Width = 61
	
	PROCEDURE about		&& Provides documentation for the class.
		*==============================================================================
		* Class:					SFOptionGroup
		* Based On:					OptionGroup
		* Purpose:					Base class for all OptionGroup objects
		* Author:					Doug Hennig
		* Copyright:				(c) 1996, 2000 Stonefield Systems Group Inc.
		* Last revision:			08/30/2000
		* Include file:				SFCTRLS.H
		*
		* Changes in "Based On" class properties:
		*	BackStyle:				0 (Transparent)
		*
		* Changes in "Based On" class methods:
		*	Destroy:				nukes member objects
		*	Error:					calls the parent Error method so error handling
		*							goes up the containership hierarchy
		*	InteractiveChange:		call This.AnyChange()
		*	ProgrammaticChange:		call This.AnyChange()
		*	RightClick:				call This.ShowMenu()
		*	Valid:					prevent validation code from executing if the user
		*							is cancelling, retain focus if a field rule failed,
		*							and call the custom Validation() method
		*
		* Custom public properties added:
		*	Builder:				holds the name of a custom builder
		*	BuilderX:				holds the name of the preferred custom builder
		*	lUseFormShortcutMenu:	.T. if the form's shortcut menu items should be
		*							included with this object's
		*	oHook:					a reference to a hooked object (default = .NULL.)
		*	oMenu:					a reference to an SFShortcutMenu object (default =
		*							.NULL.)
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	About:					provides documentation for the class
		*	AnyChange:				called by InteractiveChange() and
		*							ProgrammaticChange()
		*	Enabled_Access:			sets the Enabled property of the object and all
		*							member objects to the specified value so all
		*							objects appear to be enabled or disabled
		*	Release:				releases the object
		*	ShortcutMenu:			populates the shortcut menu
		*	ShowMenu:				display a shortcut menu
		*	Validation:				abstract method for custom validation code
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE anychange		&& Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place.
	ENDPROC

	PROCEDURE enabled_assign
		* Enable or disable member objects.
		
		lparameters tlEnabled
		This.SetAll('Enabled', tlEnabled)
		This.Enabled = tlEnabled
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	03/04/2000
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local laError[1], ;
			lcName, ;
			lcMethod, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcSource, ;
			lcMessage, ;
			lnChoice
		
		* Get information about the error.
		
		aerror(laError)
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, tnLine, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(tnError, lcMethod, tnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, tnLine, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(tnError, lcMethod, tnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',tnError')
				lcError = strtran(lcError, ' ERROR()',  ' tnError')
				lcError = strtran(lcError, 'LINENO()',  'tnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + ltrim(str(tnError)) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(tnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					ltrim(str(tnLine)) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
					'Choose Yes to display the debugger, No to continue ' + ;
					'without the debugger, or Cancel to cancel execution', ;
					MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE InteractiveChange
		* Call a common method for handling changes.
		
		This.AnyChange()
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		* Call a common method for handling changes.
		
		This.AnyChange()
		
	ENDPROC

	PROCEDURE release		&& Releases the object.
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	12/11/98
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	02/10/2000
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	MAKEOBJECT.PRG and SFMENU.VCX can be found (and VARTYPE.PRG
		*						in VFP 5)
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			if vartype(.oMenu) <> 'O'
				.oMenu = MakeObject('SFShortcutMenu', 'SFMENU.VCX')
			endif vartype(.oMenu) <> 'O'
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

	PROCEDURE Valid
		*==============================================================================
		* Method:			Valid
		* Status:			Public
		* Purpose:			Validate the Value
		* Author:			Doug Hennig
		* Copyright:		(c) 1996, 2000 Stonefield Systems Group Inc.
		* Last revision:	08/30/2000
		* Parameters:		none
		* Returns:			.T. if the validation succeeded or we're not doing the
		*						validation
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		* If the Valid method is fired because the user clicked on a button with the
		* Cancel property set to .T. or if the button has an lCancel property (which
		* is part of the SFCommandButton base class) and it's .T., or if we're closing
		* the form, don't bother doing the rest of the validation.
		
		local loObject
		loObject = sys(1270)
		if (type('loObject.Cancel') = 'L' and loObject.Cancel) or ;
			(type('loObject.lCancel') = 'L' and loObject.lCancel) or ;
			(type('Thisform.ReleaseType') = 'N' and Thisform.ReleaseType > 0)
			return .T.
		endif (type('loObject.lCancel') = 'L' ...
		
		* If the user tries to leave this control but a field validation rule failed,
		* we'll prevent them from doing so.
		
		if type('Thisform.lFieldRuleFailed') = 'L' and Thisform.lFieldRuleFailed
			Thisform.lFieldRuleFailed = .F.
			return 0
		endif type('Thisform.lFieldRuleFailed') = 'L' ...
		
		* Do the custom validation (this allows the developer to put custom validation
		* code into the Validation method rather than having to use code like the
		* following in the Valid method:
		*
		* dodefault()
		* custom code here
		* nodefault
		
		return This.Validation()
		
	ENDPROC

	PROCEDURE validation		&& Abstract method for custom validation code
	ENDPROC

ENDDEFINE

DEFINE CLASS sfpageactivate AS sfline OF "sfctrls.vcx" 
 	*< CLASSDATA: Baseclass="line" Timestamp="" Scale="Pixels" Uniqueid="" />

	Name = "sfpageactivate"
	Visible = .F.
	
	PROCEDURE UIEnable
		LPARAMETERS lEnable
		with Thisform
			if lEnable
				.LockScreen = .T.
				This.Parent.Refresh()
				if pemstatus(Thisform, 'SetFocusToFirstObject', 5)
					.SetFocusToFirstObject(This.Parent)
				endif pemstatus(Thisform, 'SetFocusToFirstObject', 5)
				.LockScreen = .F.
			endif lEnable
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfpageframe AS pageframe 		&& The base class for PageFrame objects
 	*< CLASSDATA: Baseclass="pageframe" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: getpagenumber		&& Gets the page number in the Pages collection that matches the specified page order
		*m: release		&& Releases the object.
		*m: setenabled		&& Sets the Enabled property of the specified page and all member objects to the specified value so all objects appear to be enabled or disabled.
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class.
		*p: builderx		&& Holds the name of the preferred custom builder
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to an SFShortcutMenu object
	*</DefinedPropArrayMethod>

	ActivePage = 1
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class.
	builderx = ( home() + 'wizards\builderd, builderdform')		&& Holds the name of the preferred custom builder
	ErasePage = .T.
	Height = 250
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Name = "sfpageframe"
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to an SFShortcutMenu object
	PageCount = 1
	TabStop = .F.
	TabStyle = 1
	Page1.Caption = "Page1"
	Page1.Name = "Page1"
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:					SFPageFrame
		* Based On:					PageFrame
		* Purpose:					Base class for all PageFrame objects
		* Author:					Doug Hennig
		* Copyright:				(c) 1996-2001 Stonefield Systems Group Inc.
		* Last revision:			10/11/2001
		* Include file:				SFCTRLS.H
		*
		* Changes in "Based On" class properties:
		*	PageCount:				1
		*	TabStop:				.F. so the user can't set focus to pages from the
		*							keyboard
		*	TabStyle:				1 (Non-justified)
		*
		* Changes in "Based On" class methods:
		*	Destroy:				nuke member objects
		*	Error:					calls the parent Error method so error handling
		*							goes up the containership hierarchy
		*	Init:					add an SFPageActivate object to every page
		*	RightClick:				call This.ShowMenu()
		*
		* Custom public properties added:
		*	Builder:				holds the name of a custom builder
		*	BuilderX:				holds the name of the preferred custom builder
		*	lUseFormShortcutMenu:	.T. if the form's shortcut menu items should be
		*							included with this object's
		*	oHook:					a reference to a hooked object (default = .NULL.)
		*	oMenu:					a reference to an SFShortcutMenu object (default =
		*							.NULL.)
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	About:					provides documentation for the class
		*	GetPageNumber:			gets the page number in the Pages collection that
		*							matches the specified page order
		*	Release:				releases the object
		*	SetEnabled:				sets the Enabled property of the specified page and
		*							all member objects to the specified value so all
		*							objects appear to be enabled or disabled
		*	ShortcutMenu:			populates the shortcut menu
		*	ShowMenu:				display a shortcut menu
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		This.oMenu = .NULL.
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	03/04/2000
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local laError[1], ;
			lcName, ;
			lcMethod, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcSource, ;
			lcMessage, ;
			lnChoice
		
		* Get information about the error.
		
		aerror(laError)
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, tnLine, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(tnError, lcMethod, tnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, tnLine, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(tnError, lcMethod, tnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',tnError')
				lcError = strtran(lcError, ' ERROR()',  ' tnError')
				lcError = strtran(lcError, 'LINENO()',  'tnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + ltrim(str(tnError)) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(tnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					ltrim(str(tnLine)) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
					'Choose Yes to display the debugger, No to continue ' + ;
					'without the debugger, or Cancel to cancel execution', ;
					MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE getpagenumber		&& Gets the page number in the Pages collection that matches the specified page order
		* Gets the page number in the Pages collection that matches the specified page
		* order. These values won't be the same if the PageOrder property for any page
		* has been changed.
		
		lparameters tnActivePage
		local lnPage
		with This
			lnPage = 0
			for lnI = 1 to .PageCount
				if .Pages[lnI].PageOrder = tnActivePage
					lnPage = lnI
					exit
				endif .Pages[lnI].PageOrder = tnActivePage
			next lnI
		endwith
		return lnPage
		
	ENDPROC

	PROCEDURE Init
		* Add an SFPageActivate object to every page so when the page gets activated,
		* it gets refreshed and focus is set to the first object on the page.
		
		local llAdd, ;
			loPage
		llAdd = '\SFCTRLS.VCX' $ upper('CLASSLIB')
		for each loPage in This.Pages
			if llAdd
				loPage.AddObject('oActivate', 'SFPageActivate')
			else
				loPage.NewObject('oActivate', 'SFPageActivate', 'SFCtrls.vcx')
			endif llAdd
		next loPage
		
	ENDPROC

	PROCEDURE release		&& Releases the object.
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE setenabled		&& Sets the Enabled property of the specified page and all member objects to the specified value so all objects appear to be enabled or disabled.
		* If a page is enabled or disabled, so the same for every control on the page
		* so they appear disabled.
		
		lparameters tnPage, ;
			tlEnabled
		with This.Pages[tnPage]
			if This.ActivePage = tnPage
				.SetAll('Enabled', tlEnabled)
			endif This.ActivePage = tnPage
			.Enabled = tlEnabled
		endwith
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	12/11/98
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	02/10/2000
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	MAKEOBJECT.PRG and SFMENU.VCX can be found (and VARTYPE.PRG
		*						in VFP 5)
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			if vartype(.oMenu) <> 'O'
				.oMenu = MakeObject('SFShortcutMenu', 'SFMENU.VCX')
			endif vartype(.oMenu) <> 'O'
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfparameter AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: createarray		&& Creates an array property
		*m: this_access		&& Adds a property if it doesn't exist
	*</DefinedPropArrayMethod>

	Name = "sfparameter"
	Width = 17
	
	PROCEDURE createarray		&& Creates an array property
		* Create an array property.
		
		lparameters tcArray, ;
			tnRows, ;
			tnColumns
		local lnRows
		lnRows = iif(vartype(tnRows) = 'N', tnRows, 1)
		if vartype(tnColumns) = 'N'
			This.AddProperty(tcArray + '[lnRows, tnColumns]')
		else
			This.AddProperty(tcArray + '[lnRows]')
		endif vartype(tnColumns) = 'N'
		
	ENDPROC

	PROCEDURE this_access		&& Adds a property if it doesn't exist
		* Add the specified property if it doesn't exist.
		
		lparameters tcMember
		if not pemstatus(This, tcMember, 5)
			This.AddProperty(tcMember)
		endif not pemstatus(This, tcMember, 5)
		return This
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfseparator AS separator 		&& The base class for Separator objects
 	*< CLASSDATA: Baseclass="separator" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class.
		*m: release		&& Releases the object.
	*</DefinedPropArrayMethod>

	Height = 0
	Name = "sfseparator"
	Width = 0
	
	PROCEDURE about		&& Provides documentation for the class.
		*==============================================================================
		* Class:					SFSeparator
		* Based On:					Separator
		* Purpose:					The base class for all Separator objects
		* Author:					Doug Hennig
		* Copyright:				(c) 1996-2001 Stonefield Systems Group Inc.
		* Last revision:			07/15/2001
		* Include file:				SFCTRLS.H
		*
		* Changes in "Based On" class properties:
		*	None
		*
		* Changes in "Based On" class methods:
		*	Init:					use a vertical rule in VFP 7 or later
		*
		* Custom public properties added:
		*	None
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	About:					provides documentation for the class
		*	Release:				releases the object
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Init
		* Use a vertical rule in VFP 7 or later.
		
		if clVFP7ORLATER
			This.Style = 1
		endif clVFP7ORLATER
		
	ENDPROC

	PROCEDURE release		&& Releases the object.
		* Release the object.
		
		release This
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfshape AS shape 		&& The base class for all Shape objects
 	*< CLASSDATA: Baseclass="shape" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class.
		*m: release		&& Releases the object.
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class.
		*p: builderx		&& Holds the name of the preferred custom builder
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to an SFShortcutMenu object
	*</DefinedPropArrayMethod>

	BackStyle = 0
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class.
	builderx = ( home() + 'wizards\builderd, builderdform')		&& Holds the name of the preferred custom builder
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Name = "sfshape"
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to an SFShortcutMenu object
	SpecialEffect = 0
	
	PROCEDURE about		&& Provides documentation for the class.
		*==============================================================================
		* Class:					SFShape
		* Based On:					Shape
		* Purpose:					The base class for all Shape objects
		* Author:					Doug Hennig
		* Copyright:				(c) 1996 Stonefield Systems Group Inc.
		* Last revision:			03/04/2000
		* Include file:				SFCTRLS.H
		*
		* Changes in "Based On" class properties:
		*	BackStyle:				0 - Transparent
		*	SpecialEffect:			0 - 3D
		*
		* Changes in "Based On" class methods:
		*	Destroy:				nukes member objects
		*	Error:					calls the parent Error method so error handling
		*							goes up the containership hierarchy
		*	RightClick:				call This.ShowMenu()
		*
		* Custom public properties added:
		*	Builder:				holds the name of a custom builder
		*	BuilderX:				holds the name of the preferred custom builder
		*	lUseFormShortcutMenu:	.T. if the form's shortcut menu items should be
		*							included with this object's
		*	oHook:					a reference to a hooked object (default = .NULL.)
		*	oMenu:					a reference to an SFShortcutMenu object (default =
		*							.NULL.)
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	About:					provides documentation for the class
		*	Release:				releases the object
		*	ShortcutMenu:			populates the shortcut menu
		*	ShowMenu:				display a shortcut menu
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		This.oMenu = .NULL.
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	03/04/2000
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local laError[1], ;
			lcName, ;
			lcMethod, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcSource, ;
			lcMessage, ;
			lnChoice
		
		* Get information about the error.
		
		aerror(laError)
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, tnLine, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(tnError, lcMethod, tnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, tnLine, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(tnError, lcMethod, tnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',tnError')
				lcError = strtran(lcError, ' ERROR()',  ' tnError')
				lcError = strtran(lcError, 'LINENO()',  'tnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + ltrim(str(tnError)) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(tnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					ltrim(str(tnLine)) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
					'Choose Yes to display the debugger, No to continue ' + ;
					'without the debugger, or Cancel to cancel execution', ;
					MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE release		&& Releases the object.
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	12/11/98
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	02/10/2000
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	MAKEOBJECT.PRG and SFMENU.VCX can be found (and VARTYPE.PRG
		*						in VFP 5)
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			if vartype(.oMenu) <> 'O'
				.oMenu = MakeObject('SFShortcutMenu', 'SFMENU.VCX')
			endif vartype(.oMenu) <> 'O'
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfspinner AS spinner 		&& The base class for all Spinner objects
 	*< CLASSDATA: Baseclass="spinner" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class.
		*m: adjustselstart		&& Adjust SelStart as necessary
		*m: anychange		&& Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place.
		*m: release		&& Releases the object.
		*m: setcalcvalues		&& Handles changes to any of the "calculator" properties
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*m: validation		&& An abstract method for custom validation code.
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class.
		*p: builderx		&& Holds the name of the preferred custom builder
		*p: cinputmask		&& The saved InputMask
		*p: csign		&& The saved sign of the value
		*p: lcalculator		&& .T. to use calculator-style digit entry
		*p: lhasdecimal		&& .T. if the value has a decimal part
		*p: lhasinteger		&& .T. if the value has an integer part
		*p: lindecimalpart		&& .T. if the cursor is in the decimal part of the value
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: nhighvalue		&& The maximum value
		*p: nlowvalue		&& The minimum value
		*p: nselstart		&& The saved value of SelStart
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to an SFShortcutMenu object
	*</DefinedPropArrayMethod>

	PROTECTED cinputmask,csign,lhasdecimal,lhasinteger,lindecimalpart,nselstart
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class.
	builderx = ( home() + 'wizards\builderd, builderdform')		&& Holds the name of the preferred custom builder
	cinputmask = 		&& The saved InputMask
	csign = 		&& The saved sign of the value
	lcalculator = .T.		&& .T. to use calculator-style digit entry
	lhasdecimal = .F.		&& .T. if the value has a decimal part
	lhasinteger = .T.		&& .T. if the value has an integer part
	lindecimalpart = .F.		&& .T. if the cursor is in the decimal part of the value
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Name = "sfspinner"
	nhighvalue = 999999999		&& The maximum value
	nlowvalue = -99999999		&& The minimum value
	nselstart = 0		&& The saved value of SelStart
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to an SFShortcutMenu object
	SelectOnEntry = .T.
	
	PROCEDURE about		&& Provides documentation for the class.
		*==============================================================================
		* Class:					SFSpinner
		* Based On:					Spinner
		* Purpose:					The base class for all Spinner objects
		* Author:					Doug Hennig. "Calculator-style" entry based on code
		*							by Marcelo Ris published in FoxPro Advisor, June
		*							1999
		* Copyright:				(c) 1996, 2000 Stonefield Systems Group Inc.
		* Last revision:			11/16/2000
		* Include file:				SFCTRLS.H
		*
		* Changes in "Based On" class properties:
		*	SelectOnEntry:			.T.
		*
		* Changes in "Based On" class methods:
		*	Click:					if we're acting like a calculator, make any
		*							necessary adjustments to SelStart
		*	Destroy:				nukes member objects
		*	Error:					calls the parent Error method so error handling
		*							goes up the containership hierarchy
		*	GotFocus:				ensure the text is selected when the control
		*							receives focus with the mouse, and if we're acting
		*							like a calculator, adjust SelStart to be in the
		*							integer part
		*	Init:					initialize "calculator" values
		*	InteractiveChange:		set SelStart to its saved value and make any
		*							necessary adjustments, then call This.AnyChange()
		*	KeyPress:				handle calculator-style entry
		*	ProgrammaticChange:		set SelStart to its saved value and make any
		*							necessary adjustments, then call This.AnyChange()
		*	RightClick:				call This.ShowMenu()
		*	Valid:					prevent validation code from executing if the user
		*							is cancelling, retain focus if a field rule failed,
		*							and call the custom Validation() method
		*
		* Custom public properties added:
		*	Builder:				holds the name of a custom builder
		*	BuilderX:				holds the name of the preferred custom builder
		*	lCalculator:			.T. to use calculator-style digit entry
		*	lUseFormShortcutMenu:	.T. if the form's shortcut menu items should be
		*							included with this object's
		*	nHighValue:				the maximum value
		*	nLowValue:				the minimum value
		*	oHook:					a reference to a hooked object (default = .NULL.)
		*	oMenu:					a reference to an SFShortcutMenu object (default =
		*							.NULL.)
		*
		* Custom protected properties added:
		*	cInputMask:				the saved InputMask
		*	cSign:					the saved sign of the value
		*	lHasDecimal:			.T. if the value has a decimal part
		*	lHasInteger:			.T. if the value has an integer part
		*	lInDecimalPart:			.T. if the cursor is in the decimal part of the
		*							value
		*	nSelStart:				the saved value of SelStart
		*
		* Custom public methods added:
		*	About:					provides documentation for the class
		*	AnyChange:				called by InteractiveChange() and
		*							ProgrammaticChange()
		*	Release:				releases the object
		*	SetCalcValues:			handles changes to any of the "calculator"
		*							properties
		*	ShortcutMenu:			populates the shortcut menu
		*	ShowMenu:				display a shortcut menu
		*	Validation:				abstract method for custom validation code
		*
		* Custom protected methods added:
		*	AdjustSelStart:			adjust SelStart as necessary
		*==============================================================================
		
	ENDPROC

	PROTECTED PROCEDURE adjustselstart		&& Adjust SelStart as necessary
		lparameters tnMove
		local lnLen, ;
			lcText1, ;
			lcText2, ;
			lnMin, ;
			lnSelStart, ;
			lnMove, ;
			lnSelLength, ;
			lnPos, ;
			lnChar
		with This
		
		* Calculate the minimum position for the cursor by removing any non-digit
		* characters from the InputMask.
		
			lnLen   = len(.InputMask)
			lcText1 = .Text
			lcText2 = ltrim(lcText1)
			do while not empty(lcText2) and not isdigit(left(lcText2, 1))
				lcText2 = ltrim(right(lcText2, len(lcText2) - 1))
			enddo while not empty(lcText2) ...
			lnMin = len(lcText1) - len(lcText2)
		
		* Calculate the the new cursor position, keeping it between the maximum and
		* minimum values.
		
			lnSelStart = .SelStart + tnMove
			do case
				case lnSelStart < lnMin
					lnSelStart = lnMin
					lnMove     = 0
				case lnSelStart > lnLen
					lnSelStart = lnLen
					lnMove     = 0
				otherwise
					lnMove = tnMove
			endcase
		
		* Depending on whether we're moving positive or negative, move the cursor right
		* or left every time there is a non-digit on the left.
		
			if lnMove >= 0
				do while lnSelStart < lnLen and ;
					substr(.InputMask, lnSelStart + 1, 1) <> '9'
					lnSelStart = lnSelStart + 1
				enddo while lnSelStart < lnLen ...
			else
				do while lnSelStart > lnMin and ;
					substr(.InputMask, lnSelStart + 1, 1) <> '9'
					lnSelStart = lnSelStart - 1
				enddo while lnSelStart > lnMin ...
			endif lnMove >= 0
		
		* Adjust SelLength as necessary, then adjust SelStart to the new position.
		
			lnSelLength = .SelLength
			if lnSelLength > 0
				lnSelLength = max(lnSelLength - (lnSelStart - .SelStart), 0)
			endif lnSelLength > 0
			.SelStart  = lnSelStart
			.nSelStart = lnSelStart
			.SelLength = lnSelLength
		
		* Set the spinner's increment to the value (integer or decimal) corresponding
		* to the left position of the cursor.
		
			lnPos   = lnSelStart + 1
			lnChar  = 1
			lcText1 = .InputMask
			do while lnChar <= len(lcText1) 
				lcText2 = substr(lcText1, lnChar, 1)
				do case
					case lcText2 = '.'
						if lnChar <= lnSelStart
							lnPos = lnPos - 1
						endif lnChar <= lnSelStart
						lnChar = lnChar + 1
			      	case not isdigit(lcText2)
						if lnChar <= lnSelStart
							lnPos = lnPos - 1
						endif lnChar <= lnSelStart
						lcText1    = stuff(lcText1, lnChar, 1, '')
						lnSelStart = lnSelStart - 1
					otherwise
						lnChar = lnChar + 1
				endcase
			enddo while lnChar <= len(lcText1) 
			.Increment = val(strtran(stuff(lcText1, lnPos, 0, '1'), '9', '0'))
		endwith
		
	ENDPROC

	PROCEDURE anychange		&& Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place.
	ENDPROC

	PROCEDURE Click
		* If we're acting like a calculator, make any necessary adjustments to
		* SelStart.
		
		with This
			if .lCalculator
				.AdjustSelStart(0)
			endif .lCalculator
		endwith
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		This.oMenu = .NULL.
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	03/04/2000
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local laError[1], ;
			lcName, ;
			lcMethod, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcSource, ;
			lcMessage, ;
			lnChoice
		
		* Get information about the error.
		
		aerror(laError)
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, tnLine, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(tnError, lcMethod, tnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, tnLine, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(tnError, lcMethod, tnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',tnError')
				lcError = strtran(lcError, ' ERROR()',  ' tnError')
				lcError = strtran(lcError, 'LINENO()',  'tnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + ltrim(str(tnError)) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(tnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					ltrim(str(tnLine)) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
					'Choose Yes to display the debugger, No to continue ' + ;
					'without the debugger, or Cancel to cancel execution', ;
					MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE GotFocus
		with This
		
		* If we're acting like a calculator, adjust SelStart to be in the integer part.
		
			do case
				case .lCalculator
					if .lHasDecimal
						.AdjustSelStart(at('.', .InputMask) - .SelStart)
					else
						.AdjustSelStart(len(.InputMask) - .SelStart)
					endif .lHasDecimal
					.lInDecimalPart = not .lHasInteger
		
		* Ensure the text is selected when the control receives focus with the mouse.
		
				case .SelectOnEntry
					dodefault()
			endcase
		endwith
		
	ENDPROC

	PROCEDURE Init
		with This
		
		* Initialize "calculator" properties.
		
			if .lCalculator
				.SetCalcValues()
			endif .lCalculator
		endwith
		
	ENDPROC

	PROCEDURE InteractiveChange
		with This
		
		* If we're acting like a calculator, set SelStart to its saved value and then
		* make any necessary adjustments.
		
			if .lCalculator
				.SelStart = .nSelStart
				.AdjustSelStart(0)
			endif .lCalculator
		
		* Call a common method for handling changes.
		
			.AnyChange()
		endwith
		
	ENDPROC

	PROCEDURE KeyPress
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		local lnSelEnd, ;
			lcString, ;
			lnPos, ;
			llIntPart, ;
			lnLen, ;
			lnI, ;
			lcChar, ;
			lnAddSelStart, ;
			lnValue, ;
			llIntFull, ;
			lnDecPos, ;
			llChanged, ;
			llOtherWise
		with This
			if .lCalculator
		
		* If some characters are selected and the user entered a digit or hit Del,
		* replace the selected characters with the input key.
		
				if .SelLength > 0 and (between(tnKeyCode, 48, 57) or ;
					tnKeyCode = 7) and tnShiftAltCtrl = 0
					lnSelEnd  = .SelStart + .SelLength
					lcString  = .Text
					lnPos     = 1
					llIntPart = .T.
					lnLen     = len(.InputMask)
		   
		* Remove the selected characters from the value.
		
					for lnI = 1 to lnLen
						lcChar = substr(.InputMask, lnI, 1)
						do case
							case not inlist(lcChar, '.', '-', ' ') and ;
								not isdigit(lcChar)
								lcString = stuff(lcString, lnPos, 1, '')
							case lcChar = '.'
								llIntPart = .F.
								lnPos     = lnPos + 1
							case not between(lnI, .SelStart + 1, lnSelEnd)
								lnPos = lnPos + 1
							case llIntPart
								lcString = stuff(lcString, lnPos, 1, '')
							otherwise
								lcString = stuff(lcString, lnPos, 1, '0')
								lnPos    = lnPos + 1
						endcase
					next lnI
		
		* Recalculate the SelStart position.
		
					lnAddSelStart = 0
					lnPos         = at('.', .InputMask)
					do case
						case lnPos = 0
							lnAddSelStart = .SelLength
						case between(lnPos, .SelStart + 1, lnSelEnd)
							lnAddSelStart = lnPos - .SelStart
						case lnPos > lnSelEnd
							lnAddSelStart = .SelLength
					endcase
		
		* Save the new value and adjust the cursor position.
		
					lnPos     = .SelStart
					.Value    = val(lcString)
					.SelStart = lnPos
					.AdjustSelStart(lnAddSelStart - (.SelStart - lnPos))
		
		* If the user hit Del, we're done.
		
					if tnKeyCode = 7
						nodefault
						return
					endif tnKeyCode = 7
				endif .SelLength > 0 ...
		
		* Save the sign if the value is non-zero.
		
				do case
					case .Value = 0
					case .Value > 0
						.cSign = ''
					otherwise
						.cSign = '-'
				endcase
		
		* Save the value, then remove non-digit characters, and substitute the cursor
		* position with CHR(1).
		
				lnValue  = .Value
				lcString = stuff(.Text, .SelStart + 1, 0, chr(1))
				lnPos    = 1
				do while lnPos <= len(lcString)
					lcChar = substr(lcString, lnPos, 1)
					if not inlist(lcChar, '.', '-', ' ', chr(1)) and ;
						not isdigit(lcChar)
						lcString = stuff(lcString, lnPos, 1, '')
					else
						lnPos = lnPos + 1
					endif not inlist(lcChar ...
				enddo while lnPos <= len(lcString)
		
		* See if the integer part is full.
		
				llIntFull = len(lcString) = len(ltrim(lcString))
				lcString  = alltrim(lcString)
		
		* Find the cursor position and remove it, then save the decimal position.
		
				lnPos    = at(chr(1), lcString) - 1
				lcString = strtran(lcString, chr(1))
				lnDecPos = at('.', lcString)
		
		* See if the cursor is in the decimal or integer position.
		
				do case
					case not .lHasDecimal
						.lInDecimalPart = .F.
					case lnPos > lnDecPos or (lnPos = lnDecPos and llIntFull)
						.lInDecimalPart = .T.
					case lnPos < lnDecPos and .lHasInteger
						.lInDecimalPart = .F.
				endcase
		
		* Process things depending on what key the user hit.
		
				lnAddSelStart = 0
				llChanged     = .F.
				llOtherwise   = .F.
				lnValue       = val(lcString)
				do case
		
		* "0" to "9": enter the digit.
		
					case between(tnKeyCode, 48, 57) and tnShiftAltCtrl = 0
						nodefault
						do case
		
		* If we're in the integer part and it isn't full, insert the character in the
		* integer part.
		
							case not .lInDecimalPart and not llIntFull
								if lnPos = lnDecPos
									lnPos = lnPos - 1
								endif lnPos = lnDecPos
								lcString  = stuff(lcString, lnPos + 1, 0, ;
									chr(tnKeyCode))
								lnValue   = val(lcString)
								llChanged = .T.
		
		* We're not at the end of the decimal area yet, so overwrite it.
		
				         	case .SelStart < len(.InputMask)
								lcString      = stuff(lcString, lnPos + 1, 1, ;
									chr(tnKeyCode))
								lnAddSelStart = 1
								lnValue       = val(lcString)
								llChanged     = .T.
						endcase
		
		* Backspace: remove the digit to the left if there is one.
		
					case tnKeyCode = 127
						nodefault
						if lnPos > 0
		
		* If we have an integer part and we're at the decimal point, move to the left
		* to put the cursor in a valid position.
		
							if .lHasInteger and substr(lcString, lnPos, 1) = '.'
								lnPos = lnPos - 1
								.lInDecimalPart = .F.
							endif .lHasInteger ...
		
		* If there is a digit on the left, remove it.
		
							if lnPos > 0 and ;
								not inlist(substr(lcString, lnPos, 1), '-', '.')
								lcString = stuff(lcString, lnPos, 1, '')
		
		* If we're at the decimal part, move the cursor to the left.
		
								if .lInDecimalPart
									lnAddSelStart = -1
								endif .lInDecimalPart
								lnValue   = val(lcString)
								llChanged = .T.
							endif lnPos > 0 ...
						endif lnPos > 0
		
		* Del: remove the digit to the right if there is one.
		
					case tnKeyCode = 7
						nodefault
						if lnPos < len(lcString) and substr(lcString, lnPos, 1) <> '-'
		
		* If we're at the decimal point and have a decimal part, put the cursor at it.
		
							if .lHasDecimal and substr(lcString, lnPos, 1) = '.'
								.lInDecimalPart = .T.
							endif .lHasDecimal ...
		
		* Remove the character after the cursor. If it's at the integer part, move to
		* the right.
		
							lcString = stuff(lcString, lnPos + 1, 1, '')
							if not .lInDecimalPart
								lnAddSelStart = 1
							endif not .lInDecimalPart
							lnValue   = val(lcString)
							llChanged = .T.
						endif lnPos < len(lcString) ...
		
		* "C": set the value to zero.
		
					case inlist(tnKeyCode, 67, 99) and inlist(tnShiftAltCtrl, 0, 1)
						nodefault
						.cSign    = ''
						lnValue   = 0.0000
						llChanged = .T.
						if .lHasDecimal
							lnAddSelStart = at('.', .InputMask) - .SelStart
						else
							lnAddSelStart = len(.InputMask) - .SelStart
						endif .lHasDecimal
						.lInDecimalPart = not .lHasInteger
		
		* +: change to positive.
		
					case tnKeyCode = 43 and inlist(tnShiftAltCtrl, 0, 1)
						nodefault
						if .SpinnerHighValue < 0
							.cSign = '-'
							if lnValue > 0
								lnValue   = -lnValue
								llChanged = .T.
							endif lnValue > 0
						else
							.cSign = ''
							if lnValue < 0
								lnValue   = -lnValue
								llChanged = .T.
							endif lnValue < 0
						endif .SpinnerHighValue < 0
		
		* -: change to negative.
		
					case tnKeyCode = 45 and inlist(tnShiftAltCtrl, 0, 1)
						nodefault
						.cSign = iif(.cSign = '-', '', '-')
						do case
							case .SpinnerLowValue < 0
								lnValue   = -lnValue
								llChanged = .T.
							case .cSign = '-'
					            .cSign = ''
						endcase
		
		* Decimal: change to decimal input.
		
					case tnKeyCode = asc('.') and inlist(tnShiftAltCtrl, 0, 1)
						nodefault
						if .lHasDecimal
							.lInDecimalPart = .T.
							lnAddSelStart = at('.', .InputMask) - .SelStart
							llChanged     = .T.
						endif .lHasDecimal
		
		* Home: move the cursor to the beginning.
		
					case tnKeyCode = 1
						nodefault
						.lInDecimalPart = not .lHasInteger
						lnAddSelStart = -.SelStart
						llChanged     = .T.
		
		* End: move the cursor to the end.
		
					case tnKeyCode = 6
						nodefault
						.lInDecimalPart = .lHasDecimal
						lnAddSelStart = len(.InputMask) - .SelStart + 1
						llChanged     = .T.
		
		* Left arrow: move the cursor to the left.
		
					case tnKeyCode = 19
						nodefault
						lnAddSelStart = -1
						llChanged     = .T.
		
		* Right arrow: move the cursor to the right.
		
					case tnKeyCode = 4
						nodefault
						lnAddSelStart = 1
						llChanged     = .T.
		
		* Ctrl-UpArrow: set the maximum value.
		
					case tnKeyCode = 141 and tnShiftAltCtrl = 2
						nodefault
						lnValue   = val(transform(.SpinnerHighValue, .cInputMask))
						.cSign    = iif(lnValue > 0, '', '-')
						llChanged = .T.
		
		* Ctrl-DownArrow: set the minimum value.
		
					case tnKeyCode = 145 and tnShiftAltCtrl = 2
						nodefault
						lnValue   = val(transform(.SpinnerLowValue, .cInputMask))
						.cSign    = iif(lnValue > 0, '', '-')
						llChanged = .T.
		
		* Don't do anything.
		
					otherwise
						llOtherwise = .T.
				endcase
		
		* If the value was changed, update the spinner's value and cursor position.
		
				if not llOtherwise and llChanged
					if (.cSign == '-' and lnValue > 0) or (.cSign == ''  and ;
						lnValue < 0)
						lnValue = -lnValue
					endif (.cSign == '-' ...
					lnPos     = .SelStart
					.Value    = lnValue
					.SelStart = lnPos
					.AdjustSelStart(lnAddSelStart)
				endif not llOtherwise ...
			endif .lCalculator
		endwith
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		with This
		
		* If we're acting like a calculator, set SelStart to its saved value and then
		* make any necessary adjustments.
		
			if .lCalculator
				.SelStart = .nSelStart
				.AdjustSelStart(0)
			endif .lCalculator
		
		* Call a common method for handling changes.
		
			.AnyChange()
		endwith
		
	ENDPROC

	PROCEDURE release		&& Releases the object.
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE setcalcvalues		&& Handles changes to any of the "calculator" properties
		local lcValue, ;
			lnPos, ;
			lcMaxMask, ;
			lnLen, ;
			lnI, ;
			lcChar, ;
			lcMinMask, ;
			lnPos, ;
			lnMax, ;
			lnMin
		with This
		
		* If the InputMask is empty, initialize it with a default value.
		
			if empty(.InputMask) and not empty(.nHighValue)
				lcValue = trim(padr(.nHighValue, 20))
				lnPos   = at('.', lcValue)
			   .InputMask = replicate('9', ceiling(log10(.nHighValue))) + ;
				   	iif(lnPos > 0, '.' + replicate('9', len(lcValue) - lnPos), '')
			endif empty(.InputMask) ...
		
		* Find the maximum mask by removing any special characters from InputMask.
		
			lcMaxMask = ''
			lnLen     = len(.InputMask)
			for lnI = 1 to lnLen
				lcChar = substr(.InputMask, lnI, 1)
				if isdigit(lcChar) or lcChar = '.'
					lcMaxMask = lcMaxMask + lcChar
				endif isdigit(lcChar) or lcChar = '.'
			next lnI
		
		* Save the maximum mask in cInputMask.
		
			.cInputMask = lcMaxMask
		
		* The minimum mask is obtained by removing the first character of the maximum
		* mask so we have one character for the sign.
		
			lcMinMask = right(lcMaxMask, len(lcMaxMask) - 1)
		
		* See if the mask has integer and decimal parts, and save it.
		
			lnPos = at('.', .InputMask) 
			if lnPos > 0
				.lHasInteger = '9' $ left(.InputMask, lnPos - 1)
				.lHasDecimal = '9' $ substr(.InputMask, lnPos)
			else
				.lHasInteger = '9' $ This.InputMask
				.lHasDecimal = .F.
			endif lnPos > 0
		
		* Set SpinnerHighValue and SpinnerLowValue to valid values. We won't set the
		* Keyboard equivalents because that prevents the user from canceling out of a
		* form without entering a valid value; instead, we'll trap that in Valid.
		
			lnMax = min(val(lcMaxMask),  .nHighValue, 2147483647)
			lnMin = max(-val(lcMinMask), .nLowValue,  -2147483647)
			.SpinnerHighValue = lnMax
			.SpinnerLowValue  = lnMin
		endwith
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Copyright:		(c) 1996, 2000 Stonefield Systems Group Inc.
		* Last revision:	11/16/2000
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		with toMenu
			.AddMenuBar('Cu\<t',   "sys(1500, '_MED_CUT',   '_MEDIT')", , , , ;
				'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly')
			.AddMenuBar('\<Copy',  "sys(1500, '_MED_COPY',  '_MEDIT')")
			.AddMenuBar('\<Paste', "sys(1500, '_MED_PASTE', '_MEDIT')", , , , ;
				'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly')
			.AddMenuBar('Cle\<ar', "sys(1500, '_MED_CLEAR', '_MEDIT')", , , , ;
				'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly')
			.AddMenuSeparator()
			.AddMenuBar('Se\<lect All', "sys(1500, '_MED_SLCTA', '_MEDIT')")
		endwith
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	02/10/2000
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	MAKEOBJECT.PRG and SFMENU.VCX can be found (and VARTYPE.PRG
		*						in VFP 5)
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			if vartype(.oMenu) <> 'O'
				.oMenu = MakeObject('SFShortcutMenu', 'SFMENU.VCX')
			endif vartype(.oMenu) <> 'O'
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

	PROCEDURE Valid
		*==============================================================================
		* Method:			Valid
		* Status:			Public
		* Purpose:			Validate the Value
		* Author:			Doug Hennig
		* Copyright:		(c) 1996, 2000 Stonefield Systems Group Inc.
		* Last revision:	08/30/2000
		* Parameters:		none
		* Returns:			.T. if the validation succeeded or we're not doing the
		*						validation
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		* If the Valid method is fired because the user clicked on a button with the
		* Cancel property set to .T. or if the button has an lCancel property (which
		* is part of the SFCommandButton base class) and it's .T., or if we're closing
		* the form, don't bother doing the rest of the validation.
		
		local loObject
		loObject = sys(1270)
		if (type('loObject.Cancel') = 'L' and loObject.Cancel) or ;
			(type('loObject.lCancel') = 'L' and loObject.lCancel) or ;
			(type('Thisform.ReleaseType') = 'N' and Thisform.ReleaseType > 0)
			return .T.
		endif (type('loObject.lCancel') = 'L' ...
		
		* If the user tries to leave this control but a field validation rule failed,
		* we'll prevent them from doing so.
		
		if type('Thisform.lFieldRuleFailed') = 'L' and Thisform.lFieldRuleFailed
			Thisform.lFieldRuleFailed = .F.
			return 0
		endif type('Thisform.lFieldRuleFailed') = 'L' ...
		
		* Don't allow a value outside the valid range.
		
		if not between(This.Value, This.SpinnerLowValue, This.SpinnerHighValue)
			return 0
		endif not between(This.Value, This.SpinnerLowValue, This.SpinnerHighValue)
		
		* Do the custom validation (this allows the developer to put custom validation
		* code into the Validation method rather than having to use code like the
		* following in the Valid method:
		*
		* dodefault()
		* custom code here
		* nodefault
		
		return This.Validation()
		
	ENDPROC

	PROCEDURE validation		&& An abstract method for custom validation code.
	ENDPROC

ENDDEFINE

DEFINE CLASS sftextbox AS textbox 		&& The base class for all TextBox objects
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class.
		*m: anychange		&& Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place.
		*m: release		&& Releases the object
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*m: updatecontrolsource		&& Write This.Value to This.ControlSource; this should be called from AnyChange prior to refreshing the form
		*m: validation		&& An abstract method for custom validation code.
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class.
		*p: builderx		&& Holds the name of the preferred custom builder
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to an SFShortcutMenu object
	*</DefinedPropArrayMethod>

	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class.
	builderx = ( home() + 'wizards\builderd, builderdform')		&& Holds the name of the preferred custom builder
	IntegralHeight = .T.
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Name = "sftextbox"
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to an SFShortcutMenu object
	SelectOnEntry = .T.
	
	PROCEDURE about		&& Provides documentation for the class.
		*==============================================================================
		* Class:					SFTextBox
		* Based On:					TextBox
		* Purpose:					The base class for all TextBox objects
		* Author:					Doug Hennig
		* Copyright:				(c) 1996, 2001 Stonefield Systems Group Inc.
		* Last revision:			01/11/2001
		* Include file:				SFCTRLS.H
		*
		* Changes in "Based On" class properties:
		*	IntegralHeight:			.T.
		*	SelectOnEntry:			.T.
		*
		* Changes in "Based On" class methods:
		*	Destroy:				nukes member objects
		*	Error:					calls the parent Error method so error handling
		*							goes up the containership hierarchy
		*	GotFocus:				ensure the text is selected when the control
		*							receives focus with the mouse
		*	InteractiveChange:		call This.AnyChange()
		*	ProgrammaticChange:		call This.AnyChange()
		*	RightClick:				call This.ShowMenu()
		*	Valid:					prevent validation code from executing if the user
		*							is cancelling, retain focus if a field rule failed,
		*							and call the custom Validation() method
		*
		* Custom public properties added:
		*	Builder:				holds the name of a custom builder
		*	BuilderX:				holds the name of the preferred custom builder
		*	lUseFormShortcutMenu:	.T. if the form's shortcut menu items should be
		*							included with this object's
		*	oHook:					a reference to a hooked object (default = .NULL.)
		*	oMenu:					a reference to an SFShortcutMenu object (default =
		*							.NULL.)
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	About:					provides documentation for the class
		*	AnyChange:				called by InteractiveChange() and
		*							ProgrammaticChange()
		*	Release:				releases the object
		*	ShortcutMenu:			populates the shortcut menu
		*	ShowMenu:				display a shortcut menu
		*	Validation:				abstract method for custom validation code
		*
		* Custom protected methods added:
		*	UpdateControlSource:	write This.Value to This.ControlSource; this should
		*							be called from AnyChange prior to refreshing the
		*							form
		*==============================================================================
		
	ENDPROC

	PROCEDURE anychange		&& Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place.
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		This.oMenu = .NULL.
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	03/04/2000
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local laError[1], ;
			lcName, ;
			lcMethod, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcSource, ;
			lcMessage, ;
			lnChoice
		
		* Get information about the error.
		
		aerror(laError)
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, tnLine, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(tnError, lcMethod, tnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, tnLine, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(tnError, lcMethod, tnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',tnError')
				lcError = strtran(lcError, ' ERROR()',  ' tnError')
				lcError = strtran(lcError, 'LINENO()',  'tnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + ltrim(str(tnError)) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(tnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					ltrim(str(tnLine)) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
					'Choose Yes to display the debugger, No to continue ' + ;
					'without the debugger, or Cancel to cancel execution', ;
					MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE GotFocus
		* Ensure the text is selected when the control receives focus with the mouse.
		
		if This.SelectOnEntry
			dodefault()
		endif This.SelectOnEntry
		
	ENDPROC

	PROCEDURE InteractiveChange
		* Call a common method for handling changes.
		
		This.AnyChange()
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		* Call a common method for handling changes.
		
		This.AnyChange()
		
	ENDPROC

	PROCEDURE release		&& Releases the object
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Copyright:		(c) 1996, 2000 Stonefield Systems Group Inc.
		* Last revision:	11/16/2000
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		with toMenu
			.AddMenuBar('Cu\<t',   "sys(1500, '_MED_CUT',   '_MEDIT')", , , , ;
				'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly')
			.AddMenuBar('\<Copy',  "sys(1500, '_MED_COPY',  '_MEDIT')")
			.AddMenuBar('\<Paste', "sys(1500, '_MED_PASTE', '_MEDIT')", , , , ;
				'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly')
			.AddMenuBar('Cle\<ar', "sys(1500, '_MED_CLEAR', '_MEDIT')", , , , ;
				'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly')
			.AddMenuSeparator()
			.AddMenuBar('Se\<lect All', "sys(1500, '_MED_SLCTA', '_MEDIT')")
		endwith
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	02/10/2000
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	MAKEOBJECT.PRG and SFMENU.VCX can be found (and VARTYPE.PRG
		*						in VFP 5)
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			if vartype(.oMenu) <> 'O'
				.oMenu = MakeObject('SFShortcutMenu', 'SFMENU.VCX')
			endif vartype(.oMenu) <> 'O'
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE updatecontrolsource		&& Write This.Value to This.ControlSource; this should be called from AnyChange prior to refreshing the form
		*==============================================================================
		* Method:			UpdateControlSource
		* Status:			Protected
		* Purpose:			Updates the ControlSource with the new value
		* Author:			Doug Hennig
		* Copyright:		(c) 2001 Stonefield Systems Group Inc.
		* Last revision:	01/11/2001
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the ControlSource may have been updated
		*==============================================================================
		
		local lnPos, ;
			lcAlias, ;
			lcField
		with This
			lnPos = at('.', .ControlSource)
			if lnPos > 0 and not .Value == evaluate(.ControlSource)
				lcAlias = left(.ControlSource, lnPos - 1)
				lcField = substr(.ControlSource, lnPos + 1)
				if used(lcAlias)
					replace (lcField) with .Value in (lcAlias)
				else
					store .Value to (.ControlSource)
				endif used(lcAlias)
			endif lnPos > 0 ...
		endwith
		
	ENDPROC

	PROCEDURE Valid
		*==============================================================================
		* Method:			Valid
		* Status:			Public
		* Purpose:			Validate the Value
		* Author:			Doug Hennig
		* Copyright:		(c) 1996, 2000 Stonefield Systems Group Inc.
		* Last revision:	08/30/2000
		* Parameters:		none
		* Returns:			.T. if the validation succeeded or we're not doing the
		*						validation
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		* If the Valid method is fired because the user clicked on a button with the
		* Cancel property set to .T. or if the button has an lCancel property (which
		* is part of the SFCommandButton base class) and it's .T., or if we're closing
		* the form, don't bother doing the rest of the validation.
		
		local loObject
		loObject = sys(1270)
		if (type('loObject.Cancel') = 'L' and loObject.Cancel) or ;
			(type('loObject.lCancel') = 'L' and loObject.lCancel) or ;
			(type('Thisform.ReleaseType') = 'N' and Thisform.ReleaseType > 0)
			return .T.
		endif (type('loObject.lCancel') = 'L' ...
		
		* If the user tries to leave this control but a field validation rule failed,
		* we'll prevent them from doing so.
		
		if type('Thisform.lFieldRuleFailed') = 'L' and Thisform.lFieldRuleFailed
			Thisform.lFieldRuleFailed = .F.
			return 0
		endif type('Thisform.lFieldRuleFailed') = 'L' ...
		
		* Do the custom validation (this allows the developer to put custom validation
		* code into the Validation method rather than having to use code like the
		* following in the Valid method:
		*
		* dodefault()
		* custom code here
		* nodefault
		
		return This.Validation()
		
	ENDPROC

	PROCEDURE validation		&& An abstract method for custom validation code.
	ENDPROC

ENDDEFINE

DEFINE CLASS sftimer AS timer 		&& The base class for all Timer objects
 	*< CLASSDATA: Baseclass="timer" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class.
		*m: calledfromthisclass		&& Returns .T. if a method was called from this class
		*m: cleanup		&& Cleans up member references when the object is released or destroyed
		*m: release		&& Releases the object.
		*m: releasemembers		&& Abstract method to nuke member references
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class.
		*p: builderx		&& Holds the name of the preferred custom builder
		*p: lrelease		&& .T. as the object is being released
		*p: ohook		&& A reference to a hooked object
	*</DefinedPropArrayMethod>

	PROTECTED lrelease
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class.
	builderx = ( home() + 'wizards\builderd, builderdform')		&& Holds the name of the preferred custom builder
	Height = 23
	lrelease = .F.		&& .T. as the object is being released
	Name = "sftimer"
	ohook = .NULL.		&& A reference to a hooked object
	Width = 23
	
	PROCEDURE about		&& Provides documentation for the class.
		*==============================================================================
		* Class:					SFTimer
		* Based On:					Timer
		* Purpose:					The base class for all Timer objects
		* Author:					Doug Hennig
		* Copyright:				(c) 1996-2001 Stonefield Systems Group Inc.
		* Last revision:			09/27/2001
		* Include file:				SFCTRLS.H
		*
		* Changes in "Based On" class properties:
		*	Height:					23 so the object is small when dropped on a form
		*	Width:					23 so the object is small when dropped on a form
		*
		* Changes in "Based On" class methods:
		*	Destroy:				cleanup as the object is destroyed
		*	Error:					calls the parent Error method so error handling
		*							goes up the containership hierarchy
		*
		* Custom public properties added:
		*	Builder:				holds the name of a custom builder
		*	BuilderX:				holds the name of the preferred custom builder
		*	oHook:					a reference to a hooked object (default = .NULL.)
		*
		* Custom protected properties added:
		*	lRelease:				.T. as the object is being released
		*
		* Custom public methods added:
		*	About:					provides documentation for the class
		*	Release:				releases the object
		*	ReleaseMembers:			abstract method to nuke member references
		*
		* Custom protected methods added:
		*	CalledFromThisClass:	returns .T. if a method was called from this class
		*	Cleanup:				cleans up member references when the object is
		*							released or destroyed
		*==============================================================================
		
	ENDPROC

	PROTECTED PROCEDURE calledfromthisclass		&& Returns .T. if a method was called from this class
		*==============================================================================
		* Method:			CalledFromThisClass
		* Status:			Protected
		* Purpose:			Determines if the method that called this method was called
		*						from a method of this class or an ancestor
		* Author:			Doug Hennig
		* Copyright:		(c) 1998, 2000 Stonefield Systems Group Inc.
		* Last Revision:	09/27/2001
		* Parameters:		none
		* Returns:			.T. if the method that called this method was called from a
		*						method of this class or an ancestor
		* Environment in:	none
		* Environment out:	none
		* Notes:			The reason we want to know if the method that called this
		*						method was called from a method of this class or not is
		*						to permit "read-only" properties to be changed only by
		*						methods of this class. This would typically be called
		*						from an Assign method, such as:
		*
		*					lparameters tuNewValue
		*					if This.CalledFromThisClass()
		*						This.<property> = tuNewValue
		*					else
		*						error 1743, '<property>'   && property is read-only
		*					endif This.CalledFromThisClass()
		*==============================================================================
		
		local lnLevel, ;
			lcProgram, ;
			lcObject, ;
			loParent, ;
			laClasses[1], ;
			lnClasses, ;
			lnI, ;
			llReturn, ;
			lcThisName
		
		* Get the name of the program that called us, and get the object name from it.
		* Set loParent to our parent if there is one.
		
		lnLevel   = program(-1)
		lcProgram = iif(lnLevel > 2, upper(program(lnLevel - 2)), '')
		lcObject  = left(lcProgram, rat('.', lcProgram) - 1)
		loParent  = iif(type('This.Parent') = 'O', This.Parent, .NULL.)
		
		* Check our class hierarchy to see if we were called from ourselves or an
		* ancester method.
		
		lnClasses = aclass(laClasses, This)
		for lnI = 1 to lnClasses
			if lcObject == upper(laClasses[lnI])
				llReturn = .T.
				exit
			endif lcObject == upper(laClasses[lnI])
		next lnI
		
		* If we didn't come from ourselves or an ancestor and we have a parent, our
		* name may not match our class, so check the containership hierarchy.
		
		if not llReturn and not isnull(loParent)
			lcThisName = This.Name
			do while vartype(loParent) = 'O'
				lcThisName = loParent.Name + '.' + lcThisName
				loParent   = iif(type('loParent.Parent') = 'O', loParent.Parent, ;
					.NULL.)
			enddo while vartype(loParent) = 'O'
			llReturn = upper(lcObject) == upper(lcThisName)
		endif not llReturn ...
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE cleanup		&& Cleans up member references when the object is released or destroyed
		*==============================================================================
		* Method:			Cleanup
		* Status:			Protected
		* Purpose:			Nuke member objects
		* Author:			Doug Hennig
		* Copyright:		(c) 1998 Stonefield Systems Group Inc.
		* Last Revision:	03/24/99
		* Parameters:		none
		* Returns:			.T. if everything succeeded
		* Environment in:	This.lRelease is .T. if we're already in the process of
		*						releasing
		* Environment out:	This.lRelease is .T.
		*					This.oHook is .NULL.
		*					This.ReleaseMembers() was called
		* Notes:			This methods avoids use of "with This" to prevent potential
		*						problems with dangling object references
		*==============================================================================
		
		if This.lRelease
			return .F.
		endif This.lRelease
		This.lRelease = .T.
		This.ReleaseMembers()
		This.oHook = .NULL.
		
	ENDPROC

	PROCEDURE Destroy
		* Cleanup as the object is destroyed.
		
		This.Cleanup()
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	03/04/2000
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local laError[1], ;
			lcName, ;
			lcMethod, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcSource, ;
			lcMessage, ;
			lnChoice
		
		* Get information about the error.
		
		aerror(laError)
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, tnLine, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(tnError, lcMethod, tnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, tnLine, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(tnError, lcMethod, tnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',tnError')
				lcError = strtran(lcError, ' ERROR()',  ' tnError')
				lcError = strtran(lcError, 'LINENO()',  'tnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + ltrim(str(tnError)) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(tnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					ltrim(str(tnLine)) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
					'Choose Yes to display the debugger, No to continue ' + ;
					'without the debugger, or Cancel to cancel execution', ;
					MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE release		&& Releases the object.
		* Release the object. Note the avoidance of "with This" in this code to prevent
		* potential problems with dangling object references.
		
		if This.lRelease
			nodefault
			return .F.
		endif This.lRelease
		This.Cleanup()
		release This
		
	ENDPROC

	PROCEDURE releasemembers		&& Abstract method to nuke member references
	ENDPROC

ENDDEFINE

DEFINE CLASS sftoolbar AS toolbar 		&& The base class for all Toolbar objects
 	*< CLASSDATA: Baseclass="toolbar" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class.
		*m: afterrefresh		&& An abstract method of code to execute after a form is refreshed
		*m: beforerefresh		&& An abstract method of code to execute before a form is refreshed
		*m: cleanup		&& Cleans up member references when the object is released or destroyed
		*m: finderrorhandler		&& Find the first parent for a specified object that has code in its Error method.
		*m: handleerror		&& Calls the ErrorHandler method of the oError object (if there is a valid one) or displays a generic error message.
		*m: refreshform		&& Refreshes the form
		*m: releasemembers		&& Abstract method to nuke member references
		*m: reseterror		&& Resets lErrorOccurred and aErrorInfo.
		*m: seterror		&& Sets lErrorOccurred and aErrorInfo to information about the most recent error.
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class.
		*p: builderx		&& Holds the name of the preferred custom builder
		*p: lerrorinfosaved		&& .T. if the error information has been saved in aErrorInfo
		*p: lerroroccurred		&& .T. if an error occurred (set in Error).
		*p: lrelease		&& .T. as the object is being released
		*p: nlasterror		&& The index to the last error that occurred in aErrorInfo.
		*p: oerror		&& A reference to an ErrorMgr object.
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to an SFShortcutMenu object
		*a: aerrorinfo[1,0]		&& An array of error information.
	*</DefinedPropArrayMethod>

	PROTECTED lerrorinfosaved,lrelease
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class.
	builderx = ( home() + 'wizards\builderd, builderdform')		&& Holds the name of the preferred custom builder
	Caption = "Toolbar1"
	lerrorinfosaved = .F.		&& .T. if the error information has been saved in aErrorInfo
	lerroroccurred = .F.		&& .T. if an error occurred (set in Error).
	lrelease = .F.		&& .T. as the object is being released
	Name = "sftoolbar"
	nlasterror = 0		&& The index to the last error that occurred in aErrorInfo.
	oerror = .NULL.		&& A reference to an ErrorMgr object.
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL		&& A reference to an SFShortcutMenu object
	
	PROCEDURE about		&& Provides documentation for the class.
		*==============================================================================
		* Class:					SFToolbar
		* Based On:					Toolbar
		* Purpose:					The base class for all Toolbar objects
		* Author:					Doug Hennig
		* Copyright:				(c) 1996, 2001 Stonefield Systems Group Inc.
		* Last revision:			02/02/2001
		* Include file:				SFCTRLS.H
		*
		* Changes in "Based On" class properties:
		*	None
		*
		* Changes in "Based On" class methods:
		*	DblClick:				don't undock the toolbar on a double-click
		*	Destroy:				hides the toolbar so it disappears faster, and
		*							clean up other things
		*	Error:					calls This.SetError() and This.HandleError()
		*	Release:				call This.Cleanup()
		*	RightClick:				call This.ShowMenu()
		*
		* Custom public properties added:
		*	aErrorInfo:				an array of error information
		*	Builder:				holds the name of a custom builder
		*	BuilderX:				holds the name of the preferred custom builder
		*	lErrorOccurred:			.T. if an error occurred (set in Error)
		*	nLastError:				the index to the last error that occurred in
		*							aErrorInfo
		*	oError:					a reference to an error handling object (default =
		*							.NULL.)
		*	oHook:					a reference to a hooked object (default = .NULL.)
		*	oMenu:					a reference to an SFShortcutMenu object (default =
		*							.NULL.)
		*
		* Custom protected properties added:
		*	lErrorInfoSaved:		.T. if the error information has been saved in
		*							aErrorInfo
		*	lRelease:				.T. as the object is being released
		*
		* Custom public methods added:
		*	About:					provides documentation for the class
		*	AfterRefresh:			an abstract method of code to execute after a form
		*							is refreshed
		*	BeforeRefresh:			an abstract method of code to execute before a form
		*	FindErrorHandler:		called by the Error method of contained objects to
		*							find a parent that has code in its Error method
		*	HandleError:			calls the ErrorHandler method of the oError object
		*							(if there is a valid one) or displays a generic
		*							error message
		*	RefreshForm:			refreshes the form
		*	ReleaseMembers:			abstract method to nuke member references
		*	ResetError:				resets lErrorOccurred and aErrorInfo
		*	SetError:				sets lErrorOccurred and aErrorInfo to information
		*							about the most recent error
		*	ShortcutMenu:			populates the shortcut menu
		*	ShowMenu:				display a shortcut menu
		*
		* Custom protected methods added:
		*	Cleanup:				cleans up member references when the object is
		*							released or destroyed
		*==============================================================================
		
	ENDPROC

	PROCEDURE afterrefresh		&& An abstract method of code to execute after a form is refreshed
	ENDPROC

	PROCEDURE beforerefresh		&& An abstract method of code to execute before a form is refreshed
	ENDPROC

	PROTECTED PROCEDURE cleanup		&& Cleans up member references when the object is released or destroyed
		*==============================================================================
		* Method:			Cleanup
		* Status:			Protected
		* Purpose:			Nuke member objects
		* Author:			Doug Hennig
		* Copyright:		(c) 1998 Stonefield Systems Group Inc.
		* Last Revision:	03/04/2000
		* Parameters:		none
		* Returns:			.T. if everything succeeded
		* Environment in:	This.lRelease is .T. if we're already in the process of
		*						releasing
		* Environment out:	This.lRelease is .T.
		*					This.oHook, oError, and oMenu are .NULL.
		*					This.ReleaseMembers() was called
		* Notes:			This methods avoids use of "with This" to prevent potential
		*						problems with dangling object references
		*==============================================================================
		
		if This.lRelease
			return .F.
		endif This.lRelease
		This.lRelease = .T.
		This.ReleaseMembers()
		This.oHook    = .NULL.
		This.oError   = .NULL.
		This.oMenu    = .NULL.
		
	ENDPROC

	PROCEDURE DblClick
		* Don't undock the toolbar on a double-click.
		
		nodefault
		
	ENDPROC

	PROCEDURE Destroy
		*==============================================================================
		* Method:			Destroy
		* Status:			Public
		* Purpose:			Called when the object is being destroyed
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	03/04/2000
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the toolbar and any member objects are destroyed
		*==============================================================================
		
		with This
		
		* Hide the toolbar so it appears to go away faster.
		
			.Hide()
		
		* Cleanup as the object is destroyed.
		
			.Cleanup()
		endwith
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Called when an error occurs in this object or a member
		*						object
		* Author:			Doug Hennig
		* Copyright:		(c) 1996, 2001 Stonefield Systems Group Inc.
		* Last revision:	02/02/2001
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number where the error occurred
		* Returns:			varies
		* Environment in:	an error has occurred
		* Environment out:	control may be returned to the object/method that caused
		*						the error (either as RETURN or RETRY) or to the routine
		*						containing the READ EVENTS for the application
		*					the form may be released
		*					see This.SetError() and This.HandleError() for other
		*						environmental changes
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local laError[1], ;
			lcReturn, ;
			lcReturnToOnCancel, ;
			lnPos, ;
			lcObject
		with This
		
		* Use SetError() and HandleError() to gather error information and handle it.
		
			aerror(laError)
			.SetError(tcMethod, tnLine, @laError)
			.lErrorInfoSaved = .F.
			lcReturn = .HandleError()
		
		* Figure out where to go if the user chooses "Cancel".
		
			do case
				case left(sys(16, 1), at('.', sys(16, 1)) - 1) = 'PROCEDURE ' + ;
					upper(.Name)
					lcReturnToOnCancel = ''
				case type('.oError.cReturnToOnCancel') = 'C'
					lcReturnToOnCancel = .oError.cReturnToOnCancel
				case type('oError.cReturnToOnCancel') = 'C'
					lcReturnToOnCancel = oError.cReturnToOnCancel
				otherwise
					lcReturnToOnCancel = 'MASTER'
			endcase
		endwith
		
		* Handle the return value, depending on whether the error was "ours" or came
		* from a member.
		
		lnPos    = at('.', tcMethod)
		lcObject = iif(lnPos = 0, '', upper(left(tcMethod, lnPos - 1)))
		do case
		
		* We're supposed to close the form, so do so and return to the master program
		* (we'll just cancel if we *are* the master program).
		
			case lcReturn = ccMSG_CLOSEFORM
				This.Release()
				if empty(lcReturnToOnCancel)
					cancel
				else
					return to &lcReturnToOnCancel
				endif empty(lcReturnToOnCancel)
		
		* This wasn't our error, so return the error resolution string.
		
			case lnPos > 0 and not (lcObject == upper(This.Name) or ;
				'DATAENVIRONMENT' $ upper(tcMethod))
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* If Cancel was chosen but the master program is this form, we'll just cancel.
		
			case lcReturn = ccMSG_CANCEL and empty(lcReturnToOnCancel)
				cancel
		
		* Cancel was chosen, so return to the master program.
		
			case lcReturn = ccMSG_CANCEL
				return to &lcReturnToOnCancel
		
		* Return to the routine in error to continue on.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE finderrorhandler		&& Find the first parent for a specified object that has code in its Error method.
		*==============================================================================
		* Method:			FindErrorHandler
		* Status:			Public
		* Purpose:			Travel up the containership hierarchy until we find a
		*						parent for the specified object that has code in its
		*						Error method
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	12/04/98
		* Parameters:		toObject - an object reference to the desired object
		* Returns:			an object reference to the first parent of the specified
		*						object that has code in its Error method if one could
		*						be found, or .NULL. if not
		* Environment in:	none
		* Environment out:	none
		* Note:				this method prevents a problem with controls sitting on
		*						base class Page or Column objects -- no error trapping
		*						gets done if no custom code is directly entered into
		*						these objects
		*==============================================================================
		
		lparameters toObject
		local loParent
		loParent = toObject.Parent
		do while vartype(loParent) = 'O'
			do case
				case pemstatus(loParent, 'Error', 0)
					exit
				case type('loParent.Parent') = 'O'
					loParent = loParent.Parent
				otherwise
					loParent = .NULL.
			endcase
		enddo while vartype('loParent') = 'O'
		return loParent
		
	ENDPROC

	PROCEDURE handleerror		&& Calls the ErrorHandler method of the oError object (if there is a valid one) or displays a generic error message.
		*==============================================================================
		* Method:			HandleError
		* Status:			Public
		* Purpose:			Handles an error
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	09/09/99
		* Parameters:		none
		* Returns:			a string indicating the error resolution; see SFERRORS.H
		*						for the possible values
		* Environment in:	This.nErrorInfo points to the row in This.aErrorInfo that
		*						has information about the current error
		* Environment out:	an error message may have been displayed, or some other
		*						error resolution may have been taken
		* Notes:			if This.oError contains an error handling object, its
		*						ErrorHandler method is called
		*					if a global oError contains an error handling object, its
		*						ErrorHandler method is called
		*					if an ON ERROR routine is in effect, it's called
		*					if none of these is true, a generic error message is
		*						displayed
		*==============================================================================
		
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcErrorMessage, ;
			lcErrorInfo, ;
			lcSource, ;
			loError, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		with This
			lnError        = .aErrorInfo[.nLastError, cnAERR_NUMBER]
			lcMethod       = .Name + '.' + .aErrorInfo[.nLastError, cnAERR_METHOD]
			lnLine         = .aErrorInfo[.nLastError, cnAERR_LINE]
			lcErrorMessage = .aErrorInfo[.nLastError, cnAERR_MESSAGE]
			lcErrorInfo    = .aErrorInfo[.nLastError, cnAERR_OBJECT]
			lcSource       = .aErrorInfo[.nLastError, cnAERR_SOURCE]
		
		* Get a reference to our error handling object if there is one. It could either
		* be a member of the form or a global object.
		
			do case
				case vartype(.oError) = 'O'
					loError = .oError
				case type('oError.Name') = 'C'
					loError = oError
				otherwise
					loError = .NULL.
			endcase
			do case
		
		* If the error is "cannot set focus during valid" or "DataEnvironment already
		* unloaded", we'll let it go.
		
				case lnError = cnERR_CANT_SET_FOCUS or lnError = cnERR_DE_UNLOADED
					lcReturn = ccMSG_CONTINUE
		
		* We have an error handling object, so call its ErrorHandler() method.
		
				case not isnull(loError)
					lcReturn = loError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
				case not empty(on('ERROR'))
					lcError = upper(on('ERROR'))
					lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
					lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
					lcError = strtran(lcError, ',ERROR()',  ',lnError')
					lcError = strtran(lcError, ' ERROR()',  ' lnError')
					lcError = strtran(lcError, 'LINENO()',  'lnLine')
					lcError = strtran(lcError, 'MESSAGE()', 'lcErrorMessage')
					lcError = strtran(lcError, 'SYS(2018)', 'lcErrorInfo')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
					if left(lcError, 3) = 'DO ' or '=' $ lcError
						&lcError
						lcReturn = ccMSG_CONTINUE
					else
						lcReturn = &lcError
					endif left(lcError, 3) = 'DO ' ...
		
		* We don't have an error handling object, so display a dialog box.
		
				otherwise
					lcMessage = ccMSG_ERROR_NUM + ' ' + ltrim(str(lnError)) + ccCR + ;
						ccMSG_MESSAGE + ' ' + lcErrorMessage + ccCR + ;
						iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
						ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
						ltrim(str(lnLine)) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose Yes to display the debugger, No to continue ' + ;
						'without the debugger, or Cancel to cancel execution', ;
						MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
					lcReturn = ccMSG_CONTINUE
					do case
						case lnChoice = IDYES
							lcReturn = ccMSG_DEBUG
						case lnChoice = IDCANCEL
							lcReturn = ccMSG_CANCEL
					endcase
			endcase
		endwith
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not upper(lcReturn) $ upper(ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ;
			ccMSG_CLOSEFORM + ccMSG_DEBUG), ccMSG_CONTINUE, lcReturn)
		return lcReturn
		
	ENDPROC

	PROCEDURE refreshform		&& Refreshes the form
		*==============================================================================
		* Method:			RefreshForm
		* Status:			Public
		* Purpose:			Refreshes the form
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	11/04/98
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the form has been refreshed and any code in the
		*						BeforeRefresh and AfterRefresh methods has executed
		*==============================================================================
		
		with This
			.LockScreen = .T.
			.BeforeRefresh()
			.Refresh()
			.AfterRefresh()
			.LockScreen = .F.
		endwith
		
	ENDPROC

	PROCEDURE Release
		* Release the object. Note the avoidance of "with This" in this code to prevent
		* potential problems with dangling object references.
		
		if This.lRelease
			nodefault
			return .F.
		endif This.lRelease
		This.Cleanup()
		
	ENDPROC

	PROCEDURE releasemembers		&& Abstract method to nuke member references
	ENDPROC

	PROCEDURE reseterror		&& Resets lErrorOccurred and aErrorInfo.
		*==============================================================================
		* Method:			ResetError
		* Status:			Public
		* Purpose:			Reset lErrorOccurred and aErrorInfo
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	03/16/98
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	This.lErrorOccurred is .F.
		*					This.nLastError is 1
		*					This.aErrorInfo is dimensioned to a single blank row
		*==============================================================================
		
		with This
			.lErrorOccurred = .F.
			dimension .aErrorInfo[1, cnAERR_MAX]
			.aErrorInfo = ''
			.nLastError = 1
		endwith
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE seterror		&& Sets lErrorOccurred and aErrorInfo to information about the most recent error.
		*==============================================================================
		* Method:			SetError
		* Status:			Public
		* Purpose:			Handle errors
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	12/21/98
		* Parameters:		tcMethod - the method or function the error occurred in
		*					tnLine   - the line number within tcMethod
		*					taError  - an array of error information
		* Returns:			.T.
		* Environment in:	This.aErrorInfo is dimensioned appropriately
		*					This.lErrorSet is .T. if this method has already been called
		*						for this error
		* Environment out:	This.lErrorOccurred is .T.
		*					This.lErrorSet is .T.
		*					This.nLastError points to the current row in This.aErrorInfo
		*					This.aErrorInfo is filled with error information as
		*						follows:
		*
		*					Column	Information
		*					------	-----------
		*					1 - 7	same as AERROR()
		*					8		method error occurred in
		*					9		line error occurred on
		*					10		code causing error
		*					11		date/time error occurred
		*					12		not used
		*==============================================================================
		
		lparameters tcMethod, ;
			tnLine, ;
			taError
		local lnRows, ;
			lnCols, ;
			lnLast, ;
			lnError, ;
			lnRow, ;
			lnI
		external array taError
		with This
		
		* If we've already been called, just update the method information.
		
			if .lErrorInfoSaved
				.aErrorInfo[.nLastError, cnAERR_METHOD] = tcMethod
			else
		
		* Flag that an error occurred.
		
				.lErrorOccurred  = .T.
				.lErrorInfoSaved = .T.
				lnRows = alen(taError, 1)
				lnCols = alen(taError, 2)
				lnLast = iif(empty(.aErrorInfo[1, 1]), 0, alen(.aErrorInfo, 1))
				dimension .aErrorInfo[lnLast + lnRows, cnAERR_MAX]
		
		* For each row in the error array, put each column into our array.
		
				for lnError = 1 to lnRows
					lnRow = lnLast + lnError
					for lnI = 1 to lnCols
						.aErrorInfo[lnRow, lnI] = taError[lnError, lnI]
					next lnI
		
		* Add some additional information to the current row in our array.
		
					.aErrorInfo[lnRow, cnAERR_METHOD]   = tcMethod
					.aErrorInfo[lnRow, cnAERR_LINE]     = tnLine
					.aErrorInfo[lnRow, cnAERR_SOURCE]   = ;
						iif(message(1) = .aErrorInfo[lnRow, cnAERR_MESSAGE], '', ;
						message(1))
					.aErrorInfo[lnRow, cnAERR_DATETIME] = datetime()
				next lnError
				.nLastError = alen(.aErrorInfo, 1)
			endif not .lErrorInfoSaved
		endwith
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	12/11/98
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	02/10/2000
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	MAKEOBJECT.PRG and SFMENU.VCX can be found (and VARTYPE.PRG
		*						in VFP 5)
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		private loObject, ;
			loHook
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
		
		* Define the menu if it hasn't already been defined.
		
			if vartype(.oMenu) <> 'O'
				.oMenu = MakeObject('SFShortcutMenu', 'SFMENU.VCX')
			endif vartype(.oMenu) <> 'O'
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

ENDDEFINE
